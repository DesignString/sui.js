"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdminClient = exports.resetAdminServer = exports.GraphQLError = exports.RequestError = exports.ConnectionError = void 0;
const _ = require("lodash");
const DuplexPair = require("native-duplexpair");
const typed_error_1 = require("typed-error");
const getFetchPonyfill = require("fetch-ponyfill");
const WebSocket = require("isomorphic-ws");
const connectWebSocketStream = require("@httptoolkit/websocket-stream");
const subscriptions_transport_ws_1 = require("@httptoolkit/subscriptions-transport-ws");
const graphql_1 = require("graphql");
const { 
/** @hidden */
fetch, 
/** @hidden */
Headers } = getFetchPonyfill();
const types_1 = require("../types");
const error_1 = require("../util/error");
const promise_1 = require("../util/promise");
const schema_introspection_1 = require("./schema-introspection");
const schema_introspection_2 = require("./schema-introspection");
const admin_query_1 = require("./admin-query");
class ConnectionError extends typed_error_1.TypedError {
}
exports.ConnectionError = ConnectionError;
class RequestError extends typed_error_1.TypedError {
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}
exports.RequestError = RequestError;
class GraphQLError extends RequestError {
    constructor(response, errors) {
        super(errors.length === 0
            ? `GraphQL request failed with ${response.status} response`
            : errors.length === 1
                ? `GraphQL request failed with: ${errors[0].message}`
                : // >1
                    `GraphQL request failed, with errors:\n${errors.map((e) => e.message).join('\n')}`, response);
        this.errors = errors;
    }
}
exports.GraphQLError = GraphQLError;
const mergeClientOptions = (options, defaultOptions) => {
    if (!defaultOptions)
        return options;
    if (!options)
        return defaultOptions;
    if (defaultOptions.headers) {
        if (!options.headers) {
            options.headers = defaultOptions.headers;
        }
        else if (options.headers instanceof Headers) {
            _.forEach(defaultOptions.headers, (value, key) => {
                options.headers.append(key, value);
            });
        }
        else if (_.isObject(options.headers)) {
            Object.assign(options.headers, defaultOptions.headers);
        }
    }
    return options;
};
function requestFromAdminServer(serverUrl, path, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = `${serverUrl}${path}`;
        let response;
        try {
            response = yield fetch(url, options);
        }
        catch (e) {
            if ((0, error_1.isErrorLike)(e) && e.code === 'ECONNREFUSED') {
                throw new ConnectionError(`Failed to connect to admin server at ${serverUrl}`);
            }
            else
                throw e;
        }
        if (response.status >= 400) {
            let body = yield response.text();
            let jsonBody = null;
            try {
                jsonBody = JSON.parse(body);
            }
            catch (e) { }
            if (jsonBody && jsonBody.error) {
                throw new RequestError(jsonBody.error, response);
            }
            else {
                throw new RequestError(`Request to ${url} failed, with status ${response.status} and response body: ${body}`, response);
            }
        }
        else {
            return response.json();
        }
    });
}
/**
 * Reset a remote admin server, shutting down all Mockttp servers controlled by that
 * admin server. This is equivalent to calling `client.stop()` for all remote
 * clients of the target server.
 *
 * This can be useful in some rare cases, where a client might fail to reliably tear down
 * its own server, e.g. in Cypress testing. In this case, it's useful to reset the
 * admin server completely remotely without needing access to any previous client
 * instances, to ensure all servers from previous test runs have been shut down.
 *
 * After this is called, behaviour of any previously connected clients is undefined, and
 * it's likely that they may throw errors or experience other undefined behaviour. Ensure
 * that `client.stop()` has been called on all active clients before calling this method.
 */
function resetAdminServer(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const serverUrl = options.adminServerUrl ||
            `http://localhost:${types_1.DEFAULT_ADMIN_SERVER_PORT}`;
        yield requestFromAdminServer(serverUrl, '/reset', Object.assign(Object.assign({}, options.requestOptions), { method: 'POST' }));
    });
}
exports.resetAdminServer = resetAdminServer;
/**
 * A bare admin server client. This is not intended for general use, but can be useful when
 * building admin server plugins to mock non-HTTP protocols and other advanced use cases.
 *
 * For normal usage of Mockttp, you should use `Mockttp.getRemote()` instead, to get a Mockttp
 * remote client, which wraps this class with the full Mockttp API for mocking HTTP.
 */
class AdminClient {
    constructor(options = {}) {
        this.debug = false;
        // True if server is entirely initialized, false if it's entirely shut down, or a promise
        // that resolves to one or the other if it's currently changing state.
        this.running = false;
        this.enableDebug = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.queryMockServer(`mutation EnableDebug {
                enableDebug
            }`));
        });
        this.reset = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.queryMockServer(`mutation Reset {
                reset
            }`));
        });
        this.adminClientOptions = _.defaults(options, {
            adminServerUrl: `http://localhost:${types_1.DEFAULT_ADMIN_SERVER_PORT}`
        });
    }
    attachStreamWebsocket(adminSessionBaseUrl, targetStream) {
        var _a, _b;
        const adminSessionBaseWSUrl = adminSessionBaseUrl.replace(/^http/, 'ws');
        const wsStream = connectWebSocketStream(`${adminSessionBaseWSUrl}/stream`, {
            headers: (_b = (_a = this.adminClientOptions) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.headers // Only used in Node.js (via WS)
        });
        let streamConnected = false;
        wsStream.on('connect', () => {
            streamConnected = true;
            targetStream.pipe(wsStream);
            wsStream.pipe(targetStream, { end: false });
        });
        // We ignore errors, but websocket closure eventually results in reconnect or shutdown
        wsStream.on('error', (e) => {
            if (this.debug)
                console.warn('Admin client stream error', e);
        });
        // When the websocket closes (after connect, either close frame, error, or socket shutdown):
        wsStream.on('ws-close', (closeEvent) => __awaiter(this, void 0, void 0, function* () {
            targetStream.unpipe(wsStream);
            const serverShutdown = closeEvent.code === 1000;
            if (serverShutdown) {
                // Clean shutdown implies the server is gone, and we need to shutdown & cleanup.
                this.stop();
            }
            else if (streamConnected && (yield this.running) === true) {
                console.warn('Admin client stream unexpectedly disconnected', closeEvent);
                // Unclean shutdown means something has gone wrong somewhere. Try to reconnect.
                const newStream = this.attachStreamWebsocket(adminSessionBaseUrl, targetStream);
                new Promise((resolve, reject) => {
                    newStream.once('connect', resolve);
                    newStream.once('error', reject);
                }).then(() => {
                    // On a successful connect, business resumes as normal.
                    console.warn('Admin client stream reconnected');
                }).catch((err) => {
                    // On a failed reconnect, we just shut down completely.
                    console.warn('Admin client stream reconnection failed, shutting down', err);
                    this.stop();
                });
            }
            // If never connected successfully, we do nothing.
        }));
        return wsStream;
    }
    openStreamToMockServer(adminSessionBaseUrl) {
        // To allow reconnects, we need to not end the client stream when an individual web socket ends.
        // To make that work, we return a separate stream, which isn't directly connected to the websocket
        // and doesn't receive WS 'end' events, and then we can swap the WS inputs accordingly.
        const { socket1: wsTarget, socket2: exposedStream } = new DuplexPair();
        const wsStream = this.attachStreamWebsocket(adminSessionBaseUrl, wsTarget);
        wsTarget.on('error', (e) => exposedStream.emit('error', e));
        // These receive a lot of listeners! One channel per matcher, handler & completion checker,
        // and each adds listeners for data/error/finish/etc. That's OK, it's not generally a leak,
        // but maybe 100 would be a bit suspicious (unless you have 30+ active rules).
        exposedStream.setMaxListeners(100);
        return new Promise((resolve, reject) => {
            wsStream.once('connect', () => resolve(exposedStream));
            wsStream.once('error', reject);
        });
    }
    prepareSubscriptionClientToAdminServer(adminSessionBaseUrl) {
        const adminSessionBaseWSUrl = adminSessionBaseUrl.replace(/^http/, 'ws');
        const subscriptionUrl = `${adminSessionBaseWSUrl}/subscription`;
        this.subscriptionClient = new subscriptions_transport_ws_1.SubscriptionClient(subscriptionUrl, {
            lazy: true,
            reconnect: true,
            reconnectionAttempts: 8,
            wsOptionArguments: [this.adminClientOptions.requestOptions]
        }, WebSocket);
        this.subscriptionClient.onError((e) => {
            if (this.debug)
                console.error("Subscription error", e);
        });
        this.subscriptionClient.onReconnecting(() => console.warn('Reconnecting Mockttp subscription client'));
    }
    requestFromMockServer(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Must check for session URL, not this.running, or we can't send the /stop request during shutdown!
            if (!this.adminSessionBaseUrl)
                throw new Error('Not connected to mock server');
            let url = this.adminSessionBaseUrl + path;
            let response = yield fetch(url, mergeClientOptions(options, this.adminClientOptions.requestOptions));
            if (response.status >= 400) {
                if (this.debug)
                    console.error(`Remote client server request failed with status ${response.status}`);
                throw new RequestError(`Request to ${url} failed, with status ${response.status}`, response);
            }
            else {
                return response;
            }
        });
    }
    queryMockServer(query, variables) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = (yield this.requestFromMockServer('/', {
                    method: 'POST',
                    headers: new Headers({
                        'Content-Type': 'application/json'
                    }),
                    body: JSON.stringify({ query, variables })
                }));
                const { data, errors } = yield response.json();
                if (errors && errors.length) {
                    throw new GraphQLError(response, errors);
                }
                else {
                    return data;
                }
            }
            catch (e) {
                if (this.debug)
                    console.error(`Remote client query error: ${e}`);
                if (!(e instanceof RequestError))
                    throw e;
                let graphQLErrors = undefined;
                try {
                    graphQLErrors = (yield e.response.json()).errors;
                }
                catch (e2) { }
                if (graphQLErrors) {
                    throw new GraphQLError(e.response, graphQLErrors);
                }
                else {
                    throw e;
                }
            }
        });
    }
    start(pluginStartParams) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.adminSessionBaseUrl || (yield this.running))
                throw new Error('Server is already started');
            if (this.debug)
                console.log(`Starting remote mock server`);
            const startPromise = (0, promise_1.getDeferred)();
            this.running = startPromise.then((result) => {
                this.running = result;
                return result;
            });
            try {
                const supportOldServers = 'http' in pluginStartParams;
                const portConfig = supportOldServers
                    ? pluginStartParams['http'].port
                    : undefined;
                const path = portConfig ? `/start?port=${JSON.stringify(portConfig)}` : '/start';
                const adminServerResponse = yield requestFromAdminServer(this.adminClientOptions.adminServerUrl, path, mergeClientOptions({
                    method: 'POST',
                    headers: new Headers({
                        'Content-Type': 'application/json'
                    }),
                    body: JSON.stringify(Object.assign({ plugins: pluginStartParams }, (_a = pluginStartParams.http) === null || _a === void 0 ? void 0 : _a.options))
                }, this.adminClientOptions.requestOptions));
                // Backward compat for old servers
                const isPluginAwareServer = 'id' in adminServerResponse;
                const sessionId = isPluginAwareServer
                    ? adminServerResponse.id
                    : adminServerResponse.port.toString();
                const adminSessionBaseUrl = `${this.adminClientOptions.adminServerUrl}/${isPluginAwareServer ? 'session' : 'server'}/${sessionId}`;
                // Also open a stream connection, for 2-way communication we might need later.
                this.adminServerStream = yield this.openStreamToMockServer(adminSessionBaseUrl);
                // Create a subscription client, preconfigured & ready to connect if on() is called later:
                this.prepareSubscriptionClientToAdminServer(adminSessionBaseUrl);
                // We don't persist the id or resolve the start promise until everything is set up
                this.adminSessionBaseUrl = adminSessionBaseUrl;
                // Load the schema on server start, so we can check for feature support
                this.adminServerSchema = new schema_introspection_2.SchemaIntrospector((yield this.queryMockServer(schema_introspection_1.introspectionQuery)).__schema);
                if (this.debug)
                    console.log('Started remote mock server');
                const serverMetadata = this.adminServerMetadata = // Set field before we resolve the promise
                    'pluginData' in adminServerResponse
                        ? adminServerResponse.pluginData
                        : {
                            // Backward compat - convert old always-HTTP data into per-plugin format:
                            http: adminServerResponse
                        };
                startPromise.resolve(true);
                return serverMetadata;
            }
            catch (e) {
                startPromise.resolve(false);
                throw e;
            }
        });
    }
    isRunning() {
        return this.running === true;
    }
    get metadata() {
        if (!this.isRunning())
            throw new Error("Metadata is not available until the mock server is started");
        return this.adminServerMetadata;
    }
    get schema() {
        if (!this.isRunning())
            throw new Error("Admin schema is not available until the mock server is started");
        return this.adminServerSchema;
    }
    get adminStream() {
        if (!this.isRunning())
            throw new Error("Admin stream is not available until the mock server is started");
        return this.adminServerStream;
    }
    // Call when either we want the server to stop, or it appears that the server has already stopped,
    // and we just want to ensure that's happened and clean everything up.
    stop() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.running) === false)
                return; // If stopped or stopping, do nothing.
            const stopPromise = (0, promise_1.getDeferred)();
            this.running = stopPromise.then((result) => {
                this.running = result;
                return result;
            });
            try {
                if (this.debug)
                    console.log('Stopping remote mock server');
                try {
                    (_a = this.subscriptionClient) === null || _a === void 0 ? void 0 : _a.close();
                }
                catch (e) {
                    console.log(e);
                }
                this.subscriptionClient = undefined;
                try {
                    (_b = this.adminServerStream) === null || _b === void 0 ? void 0 : _b.end();
                }
                catch (e) {
                    console.log(e);
                }
                this.adminServerStream = undefined;
                yield this.requestServerStop();
            }
            finally {
                // The client is always stopped (and so restartable) once stopping completes, in all
                // cases, since it can always be started again to reset it. The promise is just here
                // so that we successfully handle (and always wait for) parallel stops.
                stopPromise.resolve(false);
            }
        });
    }
    requestServerStop() {
        return this.requestFromMockServer('/stop', {
            method: 'POST'
        }).catch((e) => {
            if (e instanceof RequestError && e.response.status === 404) {
                // 404 means it doesn't exist, generally because it was already stopped
                // by some other parallel shutdown process.
                return;
            }
            else {
                throw e;
            }
        }).then(() => {
            this.adminSessionBaseUrl = undefined;
            this.adminServerSchema = undefined;
            this.adminServerMetadata = undefined;
        });
    }
    sendQuery(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.sendQueries(query))[0];
        });
    }
    sendQueries(...queries) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = queries.map(({ query, variables, transformResponse }) => __awaiter(this, void 0, void 0, function* () {
                const result = yield this.queryMockServer((0, graphql_1.print)(query), variables);
                return transformResponse
                    ? transformResponse(result, { adminClient: this })
                    : result;
            }));
            return Promise.all(results);
        });
    }
    subscribe(query, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.running) === false)
                throw new Error('Not connected to mock server');
            const fieldName = (0, admin_query_1.getSingleSelectedFieldName)(query);
            if (!this.schema.typeHasField('Subscription', fieldName)) {
                console.warn(`Remote client cannot subscribe to unrecognized event: ${fieldName}`);
                return Promise.resolve();
            }
            // This isn't 100% correct (you can be WS-connected, but still negotiating some GQL
            // setup) but it's good enough for our purposes (knowing-ish if the connection worked).
            let isConnected = !!this.subscriptionClient.client;
            this.subscriptionClient.request(query).subscribe({
                next: (value) => __awaiter(this, void 0, void 0, function* () {
                    if (value.data) {
                        const response = value.data[fieldName];
                        const result = query.transformResponse
                            ? yield query.transformResponse(response, { adminClient: this })
                            : response;
                        callback(result);
                    }
                    else if (value.errors) {
                        console.error('Error in subscription', value.errors);
                    }
                }),
                error: (e) => this.debug && console.warn('Error in remote subscription:', e)
            });
            return new Promise((resolve, reject) => {
                if (isConnected)
                    resolve();
                else {
                    this.subscriptionClient.onConnected(resolve);
                    this.subscriptionClient.onDisconnected(reject);
                    this.subscriptionClient.onError(reject);
                }
            });
        });
    }
    /**
     * List the names of the rule parameters defined by the admin server. This can be
     * used in some advanced use cases to confirm that the parameters a client wishes to
     * reference are available.
     *
     * Only defined for remote clients.
     */
    getRuleParameterKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.running) === false) {
                throw new Error('Cannot query rule parameters before the server is started');
            }
            if (!this.schema.queryTypeDefined('ruleParameterKeys')) {
                // If this endpoint isn't supported, that's because parameters aren't supported
                // at all, so we can safely report that immediately.
                return [];
            }
            let result = yield this.queryMockServer(`query GetRuleParameterNames {
                ruleParameterKeys
            }`);
            return result.ruleParameterKeys;
        });
    }
}
exports.AdminClient = AdminClient;
//# sourceMappingURL=admin-client.js.map