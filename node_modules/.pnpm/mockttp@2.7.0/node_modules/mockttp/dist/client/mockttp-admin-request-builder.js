"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockttpAdminRequestBuilder = void 0;
const _ = require("lodash");
const graphql_tag_1 = require("graphql-tag");
const request_utils_1 = require("../util/request-utils");
const mocked_endpoint_client_1 = require("./mocked-endpoint-client");
function normalizeHttpMessage(event, message) {
    if (message.timingEvents) {
        // Timing events are serialized as raw JSON
        message.timingEvents = JSON.parse(message.timingEvents);
    }
    else if (event !== 'tls-client-error' && event !== 'client-error') {
        // For backwards compat, all except errors should have timing events if they're missing
        message.timingEvents = {};
    }
    if (message.headers) {
        message.headers = JSON.parse(message.headers);
    }
    if (message.body !== undefined) {
        // Body is serialized as the raw encoded buffer in base64
        message.body = (0, request_utils_1.buildBodyReader)(Buffer.from(message.body, 'base64'), message.headers);
    }
    // For backwards compat, all except errors should have tags if they're missing
    if (!message.tags)
        message.tags = [];
}
class MockttpAdminRequestBuilder {
    constructor(schema) {
        this.schema = schema;
        this.getEndpointDataGetter = (adminClient, ruleId) => () => __awaiter(this, void 0, void 0, function* () {
            let result = yield adminClient.sendQuery({
                query: (0, graphql_tag_1.default) `
                    query GetEndpointData($id: ID!) {
                        mockedEndpoint(id: $id) {
                            seenRequests {
                                protocol,
                                method,
                                url,
                                path,
                                hostname,
                                headers,
                                body,
                                ${this.schema.asOptionalField('Request', 'timingEvents')}
                                ${this.schema.asOptionalField('Request', 'httpVersion')}
                            }
                            ${this.schema.asOptionalField('MockedEndpoint', 'isPending')}
                        }
                    }
                `,
                variables: { id: ruleId }
            });
            const mockedEndpoint = result.mockedEndpoint;
            if (!mockedEndpoint)
                return null;
            mockedEndpoint.seenRequests.forEach((request) => {
                request.body = (0, request_utils_1.buildBodyReader)(Buffer.from(request.body, 'base64'), request.headers);
            });
            return mockedEndpoint;
        });
    }
    buildAddRequestRulesQuery(rules, reset) {
        const requestName = (reset ? 'Set' : 'Add') + 'Rules';
        const mutationName = (reset ? 'set' : 'add') + 'Rules';
        return {
            query: (0, graphql_tag_1.default) `
                mutation ${requestName}($newRules: [MockRule!]!) {
                    endpoints: ${mutationName}(input: $newRules) {
                        id,
                        ${this.schema.asOptionalField('MockedEndpoint', 'explanation')}
                    }
                }
            `,
            variables: {
                newRules: rules
            },
            transformResponse: (response, { adminClient }) => {
                return response.endpoints.map(({ id, explanation }) => new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(adminClient, id)));
            }
        };
    }
    buildSetFallbackRequestRuleQuery(rule) {
        return {
            query: (0, graphql_tag_1.default) `
                mutation SetFallbackRule($fallbackRule: MockRule!) {
                    endpoint: setFallbackRule(input: $fallbackRule) {
                        id,
                        explanation
                    }
                }
            `,
            variables: {
                fallbackRule: rule
            },
            transformResponse: (response, { adminClient }) => {
                const { endpoint: { id, explanation } } = response;
                return new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(adminClient, id));
            }
        };
    }
    ;
    buildAddWebSocketRulesQuery(rules, reset) {
        // Seperate and simpler than buildAddRequestRulesQuery, because it doesn't have to
        // deal with backward compatibility.
        const requestName = (reset ? 'Set' : 'Add') + 'WebSocketRules';
        const mutationName = (reset ? 'set' : 'add') + 'WebSocketRules';
        return {
            query: (0, graphql_tag_1.default) `
                mutation ${requestName}($newRules: [WebSocketMockRule!]!) {
                    endpoints: ${mutationName}(input: $newRules) {
                        id,
                        explanation
                    }
                }
            `,
            variables: {
                newRules: rules
            },
            transformResponse: (response, { adminClient }) => {
                return response.endpoints.map(({ id, explanation }) => new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(adminClient, id)));
            }
        };
    }
    ;
    buildMockedEndpointsQuery() {
        return {
            query: (0, graphql_tag_1.default) `
                query GetAllEndpointData {
                    mockedEndpoints {
                        id,
                        ${this.schema.asOptionalField('MockedEndpoint', 'explanation')}
                    }
                }
            `,
            transformResponse: (response, { adminClient }) => {
                const mockedEndpoints = response.mockedEndpoints;
                return mockedEndpoints.map(({ id, explanation }) => new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(adminClient, id)));
            }
        };
    }
    buildPendingEndpointsQuery() {
        return {
            query: (0, graphql_tag_1.default) `
                query GetPendingEndpointData {
                    pendingEndpoints {
                        id,
                        explanation
                    }
                }
            `,
            transformResponse: (response, { adminClient }) => {
                const pendingEndpoints = response.pendingEndpoints;
                return pendingEndpoints.map(({ id, explanation }) => new mocked_endpoint_client_1.MockedEndpointClient(id, explanation, this.getEndpointDataGetter(adminClient, id)));
            }
        };
    }
    buildSubscriptionRequest(event) {
        if (event === 'tlsClientError')
            event = 'tls-client-error';
        // Note the asOptionalField checks - these are a quick hack for backward compatibility,
        // introspecting the server schema to avoid requesting fields that don't exist on old servers.
        const query = {
            'request-initiated': (0, graphql_tag_1.default) `subscription OnRequestInitiated {
                requestInitiated {
                    id,
                    protocol,
                    method,
                    url,
                    path,
                    ${this.schema.asOptionalField('InitiatedRequest', 'remoteIpAddress')},
                    ${this.schema.asOptionalField('InitiatedRequest', 'remotePort')},
                    hostname,

                    headers,
                    timingEvents,
                    httpVersion,
                    ${this.schema.asOptionalField('InitiatedRequest', 'tags')}
                }
            }`,
            request: (0, graphql_tag_1.default) `subscription OnRequest {
                requestReceived {
                    id,
                    ${this.schema.asOptionalField('Request', 'matchedRuleId')}
                    protocol,
                    method,
                    url,
                    path,
                    ${this.schema.asOptionalField('Request', 'remoteIpAddress')},
                    ${this.schema.asOptionalField('Request', 'remotePort')},
                    hostname,

                    headers,
                    body,
                    ${this.schema.asOptionalField('Request', 'timingEvents')}
                    ${this.schema.asOptionalField('Request', 'httpVersion')}
                    ${this.schema.asOptionalField('Request', 'tags')}
                }
            }`,
            response: (0, graphql_tag_1.default) `subscription OnResponse {
                responseCompleted {
                    id,
                    statusCode,
                    statusMessage,
                    headers,
                    body,
                    ${this.schema.asOptionalField('Response', 'timingEvents')}
                    ${this.schema.asOptionalField('Response', 'tags')}
                }
            }`,
            abort: (0, graphql_tag_1.default) `subscription OnAbort {
                requestAborted {
                    id,
                    protocol,
                    method,
                    url,
                    path,
                    hostname,

                    headers,
                    body,
                    ${this.schema.asOptionalField('Response', 'timingEvents')}
                    ${this.schema.asOptionalField('Response', 'tags')}
                }
            }`,
            'tls-client-error': (0, graphql_tag_1.default) `subscription OnTlsClientError {
                failedTlsRequest {
                    failureCause
                    hostname
                    remoteIpAddress
                    ${this.schema.asOptionalField('TlsRequest', 'remotePort')}
                    ${this.schema.asOptionalField('TlsRequest', 'tags')}
                    ${this.schema.asOptionalField('TlsRequest', 'timingEvents')}
                }
            }`,
            'client-error': (0, graphql_tag_1.default) `subscription OnClientError {
                failedClientRequest {
                    errorCode
                    request {
                        id
                        timingEvents
                        tags
                        protocol
                        httpVersion
                        method
                        url
                        path
                        headers
                        ${this.schema.asOptionalField('ClientErrorRequest', 'remoteIpAddress')},
                        ${this.schema.asOptionalField('ClientErrorRequest', 'remotePort')},
                    }
                    response {
                        id
                        timingEvents
                        tags
                        statusCode
                        statusMessage
                        headers
                        body
                    }
                }
            }`
        }[event];
        return {
            query,
            transformResponse: (data) => {
                if (event === 'client-error') {
                    data.request = _.mapValues(data.request, (v) => 
                    // Normalize missing values to undefined to match the local result
                    v === null ? undefined : v);
                    normalizeHttpMessage(event, data.request);
                    if (data.response) {
                        normalizeHttpMessage(event, data.response);
                    }
                    else {
                        data.response = 'aborted';
                    }
                }
                else {
                    normalizeHttpMessage(event, data);
                }
                return data;
            }
        };
    }
}
exports.MockttpAdminRequestBuilder = MockttpAdminRequestBuilder;
//# sourceMappingURL=mockttp-admin-request-builder.js.map