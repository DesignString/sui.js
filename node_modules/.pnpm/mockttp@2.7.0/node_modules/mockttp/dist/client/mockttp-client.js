"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockttpClient = void 0;
const _ = require("lodash");
const mockttp_1 = require("../mockttp");
const rule_serialization_1 = require("../rules/rule-serialization");
const admin_client_1 = require("./admin-client");
const mockttp_admin_request_builder_1 = require("./mockttp-admin-request-builder");
/**
 * A Mockttp implementation, controlling a remote Mockttp admin server.
 *
 * A MockttpClient supports the exact same Mockttp API as MockttpServer, but rather
 * than directly using Node.js APIs to start a mock server and rewrite traffic, it
 * makes calls to a remote admin server to start a mock server and rewrite traffic
 * there. This is useful to allow proxy configuration from inside browser tests, and
 * to allow creating mock proxies that run on remote machines.
 */
class MockttpClient extends mockttp_1.AbstractMockttp {
    constructor(options = {}) {
        super(_.defaults(options, {
            // Browser clients generally want cors enabled. For other clients, it doesn't hurt.
            // TODO: Maybe detect whether we're in a browser in future
            cors: true,
        }));
        this.reset = () => {
            return this.adminClient.reset();
        };
        this.addRequestRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addRequestRules(rules, false);
        });
        this.setRequestRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addRequestRules(rules, true);
        });
        this.addWebSocketRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addWsRules(rules, false);
        });
        this.setWebSocketRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addWsRules(rules, true);
        });
        this._addRequestRules = (rules, reset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.requestBuilder)
                throw new Error('Cannot add rules before the server is started');
            const { schema, adminStream } = this.adminClient;
            const serializedRules = rules.map((rule) => {
                const serializedRule = (0, rule_serialization_1.serializeRuleData)(rule, adminStream);
                if (!schema.typeHasInputField('MockRule', 'id')) {
                    delete serializedRule.id;
                }
                return serializedRule;
            });
            return this.adminClient.sendQuery(this.requestBuilder.buildAddRequestRulesQuery(serializedRules, reset));
        });
        this.setFallbackRequestRule = (rule) => __awaiter(this, void 0, void 0, function* () {
            if (!this.requestBuilder)
                throw new Error('Cannot add rules before the server is started');
            const { adminStream } = this.adminClient;
            return this.adminClient.sendQuery(this.requestBuilder.buildSetFallbackRequestRuleQuery((0, rule_serialization_1.serializeRuleData)(rule, adminStream)));
        });
        this._addWsRules = (rules, reset) => __awaiter(this, void 0, void 0, function* () {
            if (!this.requestBuilder)
                throw new Error('Cannot add rules before the server is started');
            const { adminStream } = this.adminClient;
            return this.adminClient.sendQuery(this.requestBuilder.buildAddWebSocketRulesQuery(rules.map((rule) => (0, rule_serialization_1.serializeRuleData)(rule, adminStream)), reset));
        });
        this.mockServerOptions = options;
        this.adminClient = new admin_client_1.AdminClient({
            adminServerUrl: options.adminServerUrl || options.standaloneServerUrl,
            requestOptions: options.client
        });
    }
    enableDebug() {
        return this.adminClient.enableDebug();
    }
    get url() {
        return this.adminClient.metadata.http.mockRoot;
    }
    get port() {
        return this.adminClient.metadata.http.port;
    }
    start(port) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.adminClient.start({
                http: {
                    port,
                    options: this.mockServerOptions
                }
            });
            this.requestBuilder = new mockttp_admin_request_builder_1.MockttpAdminRequestBuilder(this.adminClient.schema);
        });
    }
    stop() {
        return this.adminClient.stop();
    }
    getMockedEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.requestBuilder)
                throw new Error('Cannot query mocked endpoints before the server is started');
            return this.adminClient.sendQuery(this.requestBuilder.buildMockedEndpointsQuery());
        });
    }
    getPendingEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.requestBuilder)
                throw new Error('Cannot query pending endpoints before the server is started');
            return this.adminClient.sendQuery(this.requestBuilder.buildPendingEndpointsQuery());
        });
    }
    getRuleParameterKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.adminClient.getRuleParameterKeys();
        });
    }
    on(event, callback) {
        return this.adminClient.subscribe(this.requestBuilder.buildSubscriptionRequest(event), callback);
    }
}
exports.MockttpClient = MockttpClient;
//# sourceMappingURL=mockttp-client.js.map