/// <reference types="node" />
import type * as net from 'net';
import { Readable } from 'stream';
import { Headers, CompletedRequest, CompletedBody, Explainable } from "../../types";
import { MaybePromise, Replace } from '../../util/type-utils';
import { Serializable, ClientServerChannel, SerializedProxyConfig } from "../../util/serialization";
import { ProxyConfig } from '../proxy-config';
export interface RequestHandlerDefinition extends Explainable, Serializable {
    type: keyof typeof HandlerDefinitionLookup;
}
export declare type SerializedBuffer = {
    type: 'Buffer';
    data: number[];
};
export interface CallbackRequestResult {
    method?: string;
    url?: string;
    headers?: Headers;
    json?: any;
    body?: string | Buffer;
    response?: CallbackResponseResult;
}
export declare type CallbackResponseResult = CallbackResponseMessageResult | 'close';
export interface CallbackResponseMessageResult {
    statusCode?: number;
    status?: number;
    statusMessage?: string;
    headers?: Headers;
    json?: any;
    body?: string | Buffer | Uint8Array;
}
export declare class SimpleHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    status: number;
    statusMessage?: string | undefined;
    data?: string | Uint8Array | Buffer | SerializedBuffer | undefined;
    headers?: Headers | undefined;
    readonly type = "simple";
    constructor(status: number, statusMessage?: string | undefined, data?: string | Uint8Array | Buffer | SerializedBuffer | undefined, headers?: Headers | undefined);
    explain(): string;
}
/**
 * @internal
 */
export interface SerializedCallbackHandlerData {
    type: string;
    name?: string;
    version?: number;
}
/**
 * @internal
 */
export interface CallbackRequestMessage {
    args: [
        Replace<CompletedRequest, 'body', string> | CompletedRequest
    ];
}
export declare class CallbackHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    callback: (request: CompletedRequest) => MaybePromise<CallbackResponseResult>;
    readonly type = "callback";
    constructor(callback: (request: CompletedRequest) => MaybePromise<CallbackResponseResult>);
    explain(): string;
    /**
     * @internal
     */
    serialize(channel: ClientServerChannel): SerializedCallbackHandlerData;
}
/**
 * @internal
 */
export interface SerializedStreamHandlerData {
    type: string;
    status: number;
    headers?: Headers;
}
export declare class StreamHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    status: number;
    stream: Readable & {
        done?: true;
    };
    headers?: Headers | undefined;
    readonly type = "stream";
    constructor(status: number, stream: Readable & {
        done?: true;
    }, headers?: Headers | undefined);
    explain(): string;
    /**
     * @internal
     */
    serialize(channel: ClientServerChannel): SerializedStreamHandlerData;
}
export declare class FileHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    status: number;
    statusMessage: string | undefined;
    filePath: string;
    headers?: Headers | undefined;
    readonly type = "file";
    constructor(status: number, statusMessage: string | undefined, filePath: string, headers?: Headers | undefined);
    explain(): string;
}
export interface PassThroughResponse {
    id: string;
    statusCode: number;
    statusMessage?: string;
    headers: Headers;
    body: CompletedBody;
}
export interface ForwardingOptions {
    targetHost: string;
    updateHostHeader?: true | false | string;
}
export interface PassThroughLookupOptions {
    /**
     * The maximum time to cache a DNS response. Up to this limit,
     * responses will be cached according to their own TTL. Defaults
     * to Infinity.
     */
    maxTtl?: number;
    /**
     * How long to cache a DNS ENODATA or ENOTFOUND response. Defaults
     * to 0.15.
     */
    errorTtl?: number;
    /**
     * The primary servers to use. DNS queries will be resolved against
     * these servers first. If no data is available, queries will fall
     * back to dns.lookup, and use the OS's default DNS servers.
     *
     * This defaults to dns.getServers().
     */
    servers?: string[];
}
export interface PassThroughHandlerOptions {
    /**
     * The forwarding configuration for the passthrough rule.
     * This generally shouldn't be used explicitly unless you're
     * building rule data by hand. Instead, call `thenPassThrough`
     * to send data directly or `thenForwardTo` with options to
     * configure traffic forwarding.
     */
    forwarding?: ForwardingOptions;
    /**
     * A list of hostnames for which server certificate and TLS version errors
     * should be ignored (none, by default).
     */
    ignoreHostHttpsErrors?: string[];
    /**
     * Deprecated alias for ignoreHostHttpsErrors.
     * @deprecated
     */
    ignoreHostCertificateErrors?: string[];
    /**
     * An array of additional certificates, which should be trusted as certificate
     * authorities for upstream hosts, in addition to Node.js's built-in certificate
     * authorities.
     *
     * Each certificate should be an object with either a `cert` key and a string
     * or buffer value containing the PEM certificate, or a `certPath` key and a
     * string value containing the local path to the PEM certificate.
     */
    trustAdditionalCAs?: Array<{
        cert: string | Buffer;
    } | {
        certPath: string;
    }>;
    /**
     * A mapping of hosts to client certificates to use, in the form of
     * `{ key, cert }` objects (none, by default)
     */
    clientCertificateHostMap?: {
        [host: string]: {
            pfx: Buffer;
            passphrase?: string;
        };
    };
    /**
     * Upstream proxy configuration: pass through requests via this proxy.
     *
     * If this is undefined, no proxy will be used. To configure a proxy
     * provide either:
     * - a ProxySettings object
     * - a callback which will be called with an object containing the
     *   hostname, and must return a ProxySettings object or undefined.
     * - an array of ProxySettings or callbacks. The array will be
     *   processed in order, and the first not-undefined ProxySettings
     *   found will be used.
     *
     * When using a remote client, this parameter or individual array
     * values may be passed by reference, using the name of a rule
     * parameter configured in the admin server.
     */
    proxyConfig?: ProxyConfig;
    /**
     * Custom DNS options, to allow configuration of the resolver used
     * when forwarding requests upstream. Passing any option switches
     * from using node's default dns.lookup function to using the
     * cacheable-lookup module, which will cache responses.
     */
    lookupOptions?: PassThroughLookupOptions;
    /**
     * A set of data to automatically transform a request. This includes properties
     * to support many transformation common use cases.
     *
     * For advanced cases, a custom callback using beforeRequest can be used instead.
     * Using this field however where possible is typically simpler, more declarative,
     * and can be more performant. The two options are mutually exclusive: you cannot
     * use both transformRequest and a beforeRequest callback.
     *
     * Only one transformation for each target (method, headers & body) can be
     * specified. If more than one is specified then an error will be thrown when the
     * rule is registered.
     */
    transformRequest?: RequestTransform;
    /**
     * A set of data to automatically transform a response. This includes properties
     * to support many transformation common use cases.
     *
     * For advanced cases, a custom callback using beforeResponse can be used instead.
     * Using this field however where possible is typically simpler, more declarative,
     * and can be more performant. The two options are mutually exclusive: you cannot
     * use both transformResponse and a beforeResponse callback.
     *
     * Only one transformation for each target (status, headers & body) can be
     * specified. If more than one is specified then an error will be thrown when the
     * rule is registered.
     */
    transformResponse?: ResponseTransform;
    /**
     * A callback that will be passed the full request before it is passed through,
     * and which returns an object that defines how the the request content should
     * be transformed before it's passed to the upstream server.
     *
     * The callback can return an object to define how the request should be changed.
     * All fields on the object are optional, and returning undefined is equivalent
     * to returning an empty object (transforming nothing). The possible fields are:
     *
     * - `method` (a replacement HTTP verb, capitalized)
     * - `url` (a full URL to send the request to)
     * - `headers` (object with string keys & values, replaces all headers if set)
     * - `body` (string or buffer, replaces the body if set)
     * - `json` (object, to be sent as a JSON-encoded body, taking precedence
     *   over `body` if both are set)
     * - `response` (a response callback result, either a response object or 'close',
     *   if provided this will be used as an immediately response, the request will
     *   not be passed through at all, and any beforeResponse callback will never
     *   fire)
     */
    beforeRequest?: (req: CompletedRequest) => MaybePromise<CallbackRequestResult | void> | void;
    /**
     * A callback that will be passed the full response before it is passed through,
     * and which returns a value that defines how the the response content should
     * be transformed before it's returned to the client.
     *
     * The callback can either return an object to define how the response should be
     * changed, or the string 'close' to immediately close the underlying connection.
     *
     * All fields on the object are optional, and returning undefined is equivalent
     * to returning an empty object (transforming nothing). The possible fields are:
     *
     * - `status` (number, will replace the HTTP status code)
     * - `headers` (object with string keys & values, replaces all headers if set)
     * - `body` (string or buffer, replaces the body if set)
     * - `json` (object, to be sent as a JSON-encoded body, taking precedence
     *   over `body` if both are set)
     */
    beforeResponse?: (res: PassThroughResponse) => MaybePromise<CallbackResponseResult | void> | void;
}
export interface RequestTransform {
    /**
     * A replacement HTTP method. Case insensitive.
     */
    replaceMethod?: string;
    /**
     * A headers object which will be merged with the real request headers to add or
     * replace values. Headers with undefined values will be removed.
     */
    updateHeaders?: Headers;
    /**
     * A headers object which will completely replace the real request headers.
     */
    replaceHeaders?: Headers;
    /**
     * A string or buffer that replaces the request body entirely.
     *
     * If this is specified, the upstream request will not wait for the original request
     * body, so this may make responses faster than they would be otherwise given large
     * request bodies or slow/streaming clients.
     */
    replaceBody?: string | Uint8Array | Buffer;
    /**
     * The path to a file, which will be used to replace the request body entirely. The
     * file will be re-read for each request, so the body will always reflect the latest
     * file contents.
     *
     * If this is specified, the upstream request will not wait for the original request
     * body, so this may make responses faster than they would be otherwise given large
     * request bodies or slow/streaming clients.
     */
    replaceBodyFromFile?: string;
    /**
     * A JSON object which will be merged with the real request body. Undefined values
     * will be removed. Any requests which are received with an invalid JSON body that
     * match this rule will fail.
     */
    updateJsonBody?: {
        [key: string]: any;
    };
}
export interface ResponseTransform {
    /**
     * A replacement response status code.
     */
    replaceStatus?: number;
    /**
     * A headers object which will be merged with the real response headers to add or
     * replace values. Headers with undefined values will be removed.
     */
    updateHeaders?: Headers;
    /**
     * A headers object which will completely replace the real response headers.
     */
    replaceHeaders?: Headers;
    /**
     * A string or buffer that replaces the response body entirely.
     *
     * If this is specified, the downstream response will not wait for the original response
     * body, so this may make responses arrive faster than they would be otherwise given large
     * response bodies or slow/streaming servers.
     */
    replaceBody?: string | Uint8Array | Buffer;
    /**
     * The path to a file, which will be used to replace the response body entirely. The
     * file will be re-read for each response, so the body will always reflect the latest
     * file contents.
     *
     * If this is specified, the downstream response will not wait for the original response
     * body, so this may make responses arrive faster than they would be otherwise given large
     * response bodies or slow/streaming servers.
     */
    replaceBodyFromFile?: string;
    /**
     * A JSON object which will be merged with the real response body. Undefined values
     * will be removed. Any responses which are received with an invalid JSON body that
     * match this rule will fail.
     */
    updateJsonBody?: {
        [key: string]: any;
    };
}
/**
 * @internal
 */
export interface SerializedPassThroughData {
    type: 'passthrough';
    forwardToLocation?: string;
    forwarding?: ForwardingOptions;
    proxyConfig?: SerializedProxyConfig;
    ignoreHostCertificateErrors?: string[];
    extraCACertificates?: Array<{
        cert: string;
    } | {
        certPath: string;
    }>;
    clientCertificateHostMap?: {
        [host: string]: {
            pfx: string;
            passphrase?: string;
        };
    };
    lookupOptions?: PassThroughLookupOptions;
    transformRequest?: Replace<RequestTransform, 'replaceBody' | 'updateHeaders' | 'updateJsonBody', // Serialized as a string to preserve undefined values
    // Serialized as a string to preserve undefined values
    string | undefined>;
    transformResponse?: Replace<ResponseTransform, 'replaceBody' | 'updateHeaders' | 'updateJsonBody', // Serialized as a string to preserve undefined values
    // Serialized as a string to preserve undefined values
    string | undefined>;
    hasBeforeRequestCallback?: boolean;
    hasBeforeResponseCallback?: boolean;
}
/**
 * @internal
 */
export interface BeforePassthroughRequestRequest {
    args: [Replace<CompletedRequest, 'body', string>];
}
/**
 * @internal
 */
export interface BeforePassthroughResponseRequest {
    args: [Replace<PassThroughResponse, 'body', string>];
}
/**
 * Used in merging as a marker for values to omit, because lodash ignores undefineds.
 * @internal
 */
export declare const SERIALIZED_OMIT = "__mockttp__transform__omit__";
export declare class PassThroughHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    readonly type = "passthrough";
    readonly forwarding?: ForwardingOptions;
    readonly ignoreHostHttpsErrors: string[];
    readonly clientCertificateHostMap: {
        [host: string]: {
            pfx: Buffer;
            passphrase?: string;
        };
    };
    readonly extraCACertificates: Array<{
        cert: string | Buffer;
    } | {
        certPath: string;
    }>;
    readonly transformRequest?: RequestTransform;
    readonly transformResponse?: ResponseTransform;
    readonly beforeRequest?: (req: CompletedRequest) => MaybePromise<CallbackRequestResult | void> | void;
    readonly beforeResponse?: (res: PassThroughResponse) => MaybePromise<CallbackResponseResult | void> | void;
    readonly proxyConfig?: ProxyConfig;
    readonly lookupOptions?: PassThroughLookupOptions;
    protected outgoingSockets: Set<net.Socket>;
    constructor(options?: PassThroughHandlerOptions);
    explain(): string;
    /**
     * @internal
     */
    serialize(channel: ClientServerChannel): SerializedPassThroughData;
}
export declare class CloseConnectionHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    readonly type = "close-connection";
    explain(): string;
}
export declare class TimeoutHandlerDefinition extends Serializable implements RequestHandlerDefinition {
    readonly type = "timeout";
    explain(): string;
}
export declare const HandlerDefinitionLookup: {
    simple: typeof SimpleHandlerDefinition;
    callback: typeof CallbackHandlerDefinition;
    stream: typeof StreamHandlerDefinition;
    file: typeof FileHandlerDefinition;
    passthrough: typeof PassThroughHandlerDefinition;
    'close-connection': typeof CloseConnectionHandlerDefinition;
    timeout: typeof TimeoutHandlerDefinition;
};
