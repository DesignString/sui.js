"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerLookup = exports.TimeoutHandler = exports.CloseConnectionHandler = exports.PassThroughHandler = exports.FileHandler = exports.StreamHandler = exports.CallbackHandler = exports.SimpleHandler = exports.AbortError = void 0;
const _ = require("lodash");
const url = require("url");
const tls = require("tls");
const http = require("http");
const http2 = require("http2");
const https = require("https");
const h2Client = require("http2-wrapper");
const cacheable_lookup_1 = require("cacheable-lookup");
const base64_arraybuffer_1 = require("base64-arraybuffer");
const stream_1 = require("stream");
const common_tags_1 = require("common-tags");
const typed_error_1 = require("typed-error");
const http_encoding_1 = require("http-encoding");
const util_1 = require("../../util/util");
const fs_1 = require("../../util/fs");
const request_utils_1 = require("../../util/request-utils");
const buffer_utils_1 = require("../../util/buffer-utils");
const socket_util_1 = require("../../util/socket-util");
const serialization_1 = require("../../util/serialization");
const dns_1 = require("../../util/dns");
const error_1 = require("../../util/error");
const rule_parameters_1 = require("../rule-parameters");
const http_agents_1 = require("../http-agents");
const passthrough_handling_1 = require("../passthrough-handling");
const request_handler_definitions_1 = require("./request-handler-definitions");
// An error that indicates that the handler is aborting the request.
// This could be intentional, or an upstream server aborting the request.
class AbortError extends typed_error_1.TypedError {
}
exports.AbortError = AbortError;
function isSerializedBuffer(obj) {
    return obj && obj.type === 'Buffer' && !!obj.data;
}
class SimpleHandler extends request_handler_definitions_1.SimpleHandlerDefinition {
    handle(_request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.headers) {
                (0, request_utils_1.dropDefaultHeaders)(response);
                (0, request_utils_1.setHeaders)(response, this.headers);
            }
            response.writeHead(this.status, this.statusMessage);
            if (isSerializedBuffer(this.data)) {
                this.data = Buffer.from(this.data);
            }
            response.end(this.data || "");
        });
    }
}
exports.SimpleHandler = SimpleHandler;
function writeResponseFromCallback(result, response) {
    if (result.json !== undefined) {
        result.headers = _.assign(result.headers || {}, { 'Content-Type': 'application/json' });
        result.body = JSON.stringify(result.json);
        delete result.json;
    }
    if (result.headers) {
        (0, request_utils_1.dropDefaultHeaders)(response);
        validateCustomHeaders({}, result.headers);
        (0, request_utils_1.setHeaders)(response, dropUndefinedValues(result.headers));
    }
    response.writeHead(result.statusCode || result.status || 200, result.statusMessage);
    response.end(result.body || "");
}
class CallbackHandler extends request_handler_definitions_1.CallbackHandlerDefinition {
    handle(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            let req = yield (0, request_utils_1.waitForCompletedRequest)(request);
            let outResponse;
            try {
                outResponse = yield this.callback(req);
            }
            catch (error) {
                response.writeHead(500, 'Callback handler threw an exception');
                response.end((0, error_1.isErrorLike)(error) ? error.toString() : error);
                return;
            }
            if (outResponse === 'close') {
                request.socket.end();
                throw new AbortError('Connection closed (intentionally)');
            }
            else {
                writeResponseFromCallback(outResponse, response);
            }
        });
    }
    /**
     * @internal
     */
    static deserialize({ name, version }, channel) {
        const rpcCallback = (request) => __awaiter(this, void 0, void 0, function* () {
            const callbackResult = yield channel.request({ args: [
                    (version || -1) >= 2
                        ? (0, serialization_1.withSerializedBodyReader)(request)
                        : request // Backward compat: old handlers
                ] });
            if (typeof callbackResult === 'string') {
                return callbackResult;
            }
            else {
                return (0, serialization_1.withDeserializedBodyBuffer)(callbackResult);
            }
        });
        // Pass across the name from the real callback, for explain()
        Object.defineProperty(rpcCallback, "name", { value: name });
        // Call the client's callback (via stream), and save a handler on our end for
        // the response that comes back.
        return new CallbackHandler(rpcCallback);
    }
}
exports.CallbackHandler = CallbackHandler;
class StreamHandler extends request_handler_definitions_1.StreamHandlerDefinition {
    handle(_request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.stream.done) {
                if (this.headers) {
                    (0, request_utils_1.dropDefaultHeaders)(response);
                    (0, request_utils_1.setHeaders)(response, this.headers);
                }
                response.writeHead(this.status);
                this.stream.pipe(response);
                this.stream.done = true;
            }
            else {
                throw new Error((0, common_tags_1.stripIndent) `
                Stream request handler called more than once - this is not supported.

                Streams can typically only be read once, so all subsequent requests would be empty.
                To mock repeated stream requests, call 'thenStream' repeatedly with multiple streams.

                (Have a better way to handle this? Open an issue at ${require('../../../package.json').bugs.url})
            `);
            }
        });
    }
    /**
     * @internal
     */
    static deserialize(handlerData, channel) {
        const handlerStream = new stream_1.Transform({
            objectMode: true,
            transform: function (message, encoding, callback) {
                const { event, content } = message;
                let deserializedEventData = content && (content.type === 'string' ? content.value :
                    content.type === 'buffer' ? Buffer.from(content.value, 'base64') :
                        content.type === 'arraybuffer' ? Buffer.from((0, base64_arraybuffer_1.decode)(content.value)) :
                            content.type === 'nil' && undefined);
                if (event === 'data' && deserializedEventData) {
                    this.push(deserializedEventData);
                }
                else if (event === 'end') {
                    this.end();
                }
                callback();
            }
        });
        // When we get piped (i.e. to a live request), ping upstream to start streaming, and then
        // pipe the resulting data into our live stream (which is streamed to the request, like normal)
        handlerStream.once('resume', () => {
            channel.pipe(handlerStream);
            channel.write({});
        });
        return new StreamHandler(handlerData.status, handlerStream, handlerData.headers);
    }
}
exports.StreamHandler = StreamHandler;
class FileHandler extends request_handler_definitions_1.FileHandlerDefinition {
    handle(_request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            // Read the file first, to ensure we error cleanly if it's unavailable
            const fileContents = yield (0, fs_1.readFile)(this.filePath, null);
            if (this.headers) {
                (0, request_utils_1.dropDefaultHeaders)(response);
                (0, request_utils_1.setHeaders)(response, this.headers);
            }
            response.writeHead(this.status, this.statusMessage);
            response.end(fileContents);
        });
    }
}
exports.FileHandler = FileHandler;
// Used to drop `undefined` headers, which cause problems
function dropUndefinedValues(obj) {
    return _.omitBy(obj, (v) => v === undefined);
}
// Callback result bodies can take a few formats: tidy them up a little
function getCallbackResultBody(replacementBody) {
    if (replacementBody === undefined) {
        return replacementBody;
    }
    else if ((0, request_utils_1.isMockttpBody)(replacementBody)) {
        // It's our own bodyReader instance. That's not supposed to happen, but
        // it's ok, we just need to use the buffer data instead of the whole object
        return Buffer.from(replacementBody.buffer);
    }
    else if (replacementBody === '') {
        // For empty bodies, it's slightly more convenient if they're truthy
        return Buffer.alloc(0);
    }
    else {
        return (0, buffer_utils_1.asBuffer)(replacementBody);
    }
}
function getOverrideUrlLinkedHeader(originalHeaders, replacementHeaders, headerName, expectedValue) {
    const replacementValue = !!replacementHeaders ? replacementHeaders[headerName] : undefined;
    if (replacementValue !== undefined) {
        if (replacementValue !== expectedValue && replacementValue === originalHeaders[headerName]) {
            // If you rewrite the URL-based header wrongly, by explicitly setting it to the
            // existing value, we accept it but print a warning. This would be easy to
            // do if you mutate the existing headers, for example, and ignore the host.
            console.warn((0, common_tags_1.oneLine) `
                Passthrough callback overrode the URL and the ${headerName} header
                with mismatched values, which may be a mistake. The URL implies
                ${expectedValue}, whilst the header was set to ${replacementValue}.
            `);
        }
        // Whatever happens, if you explicitly set a value, we use it.
        return replacementValue;
    }
    // If you didn't override the header at all, then we automatically ensure
    // the correct value is set automatically.
    return expectedValue;
}
// Helper to autocorrect the host header, but only if you didn't explicitly
// override it yourself for some reason (e.g. testing bad behaviour).
function getCorrectHost(reqUrl, originalHeaders, replacementHeaders) {
    return getOverrideUrlLinkedHeader(originalHeaders, replacementHeaders, 'host', url.parse(reqUrl).host);
}
const OVERRIDABLE_REQUEST_PSEUDOHEADERS = [
    ':authority',
    ':scheme'
];
// We allow manually reconfiguring the :authority & :scheme headers, so that you can
// send a request to one server, and pretend it was sent to a different server, similar
// to setting a custom Host header value.
function getCorrectPseudoheaders(reqUrl, originalHeaders, replacementHeaders) {
    const parsedUrl = url.parse(reqUrl);
    return {
        ':scheme': getOverrideUrlLinkedHeader(originalHeaders, replacementHeaders, ':scheme', parsedUrl.protocol.slice(0, -1)),
        ':authority': getOverrideUrlLinkedHeader(originalHeaders, replacementHeaders, ':authority', parsedUrl.host)
    };
}
// Helper to handle content-length nicely for you when rewriting requests with callbacks
function getCorrectContentLength(body, originalHeaders, replacementHeaders, mismatchAllowed = false) {
    // If there was a content-length header, it might now be wrong, and it's annoying
    // to need to set your own content-length override when you just want to change
    // the body. To help out, if you override the body but don't explicitly override
    // the (now invalid) content-length, then we fix it for you.
    if (!_.has(originalHeaders, 'content-length')) {
        // Nothing to override - use the replacement value, or undefined
        return (replacementHeaders || {})['content-length'];
    }
    if (!replacementHeaders) {
        // There was a length set, and you've provided a body but not changed it.
        // You probably just want to send this body and have it work correctly,
        // so we should fix the content length for you automatically.
        return (0, util_1.byteLength)(body).toString();
    }
    // There was a content length before, and you're replacing the headers entirely
    const lengthOverride = replacementHeaders['content-length'] === undefined
        ? undefined
        : replacementHeaders['content-length'].toString();
    // If you're setting the content-length to the same as the origin headers, even
    // though that's the wrong value, it *might* be that you're just extending the
    // existing headers, and you're doing this by accident (we can't tell for sure).
    // We use invalid content-length as instructed, but print a warning just in case.
    if (lengthOverride === originalHeaders['content-length'] &&
        lengthOverride !== (0, util_1.byteLength)(body).toString() &&
        !mismatchAllowed // Set for HEAD responses
    ) {
        console.warn((0, common_tags_1.oneLine) `
            Passthrough modifications overrode the body and the content-length header
            with mismatched values, which may be a mistake. The body contains
            ${(0, util_1.byteLength)(body)} bytes, whilst the header was set to ${lengthOverride}.
        `);
    }
    return lengthOverride;
}
function validateCustomHeaders(originalHeaders, modifiedHeaders, headerWhitelist = []) {
    if (!modifiedHeaders)
        return;
    // We ignore most returned pseudo headers, so we error if you try to manually set them
    const invalidHeaders = _(modifiedHeaders)
        .pickBy((value, name) => name.toString().startsWith(':') &&
        // We allow returning a preexisting header value - that's ignored
        // silently, so that mutating & returning the provided headers is always safe.
        value !== originalHeaders[name] &&
        // In some cases, specific custom pseudoheaders may be allowed, e.g. requests
        // can have custom :scheme and :authority headers set.
        !headerWhitelist.includes(name))
        .keys();
    if (invalidHeaders.size() > 0) {
        throw new Error(`Cannot set custom ${invalidHeaders.join(', ')} pseudoheader values`);
    }
}
// Used in merging as a marker for values to omit, because lodash ignores undefineds.
const OMIT_SYMBOL = Symbol('omit-value');
// We play some games to preserve undefined values during serialization, because we differentiate them
// in some transforms from null/not-present keys.
const mapOmitToUndefined = (input) => _.mapValues(input, (v) => v === request_handler_definitions_1.SERIALIZED_OMIT || v === OMIT_SYMBOL
    ? undefined // Replace our omit placeholders with actual undefineds
    : v);
class PassThroughHandler extends request_handler_definitions_1.PassThroughHandlerDefinition {
    trustedCACertificates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.extraCACertificates.length)
                return undefined;
            if (!this._trustedCACertificates) {
                this._trustedCACertificates = Promise.all(tls.rootCertificates
                    .concat(this.extraCACertificates.map(certObject => {
                    if ('cert' in certObject) {
                        return certObject.cert.toString('utf8');
                    }
                    else {
                        return (0, fs_1.readFile)(certObject.certPath, 'utf8');
                    }
                })));
            }
            return this._trustedCACertificates;
        });
    }
    lookup() {
        if (!this.lookupOptions) {
            if (!this._cacheableLookupInstance) {
                // By default, use 10s caching of hostnames, just to reduce the delay from
                // endlessly 10ms query delay for 'localhost' with every request.
                this._cacheableLookupInstance = new dns_1.CachedDns(10000);
            }
            return this._cacheableLookupInstance.lookup;
        }
        else {
            if (!this._cacheableLookupInstance) {
                this._cacheableLookupInstance = new cacheable_lookup_1.default({
                    maxTtl: this.lookupOptions.maxTtl,
                    errorTtl: this.lookupOptions.errorTtl,
                    // As little caching of "use the fallback server" as possible:
                    fallbackDuration: 0
                });
                if (this.lookupOptions.servers) {
                    this._cacheableLookupInstance.servers = this.lookupOptions.servers;
                }
            }
            return this._cacheableLookupInstance.lookup;
        }
    }
    handle(clientReq, clientRes) {
        return __awaiter(this, void 0, void 0, function* () {
            // Don't let Node add any default standard headers - we want full control
            (0, request_utils_1.dropDefaultHeaders)(clientRes);
            // Capture raw request data:
            let { method, url: reqUrl, headers } = clientReq;
            let { protocol, hostname, port, path } = url.parse(reqUrl);
            const isH2Downstream = (0, request_utils_1.isHttp2)(clientReq);
            if ((0, socket_util_1.isLocalhostAddress)(hostname) && clientReq.remoteIpAddress && !(0, socket_util_1.isLocalhostAddress)(clientReq.remoteIpAddress)) {
                // If we're proxying localhost traffic from another remote machine, then we should really be proxying
                // back to that machine, not back to ourselves! Best example is docker containers: if we capture & inspect
                // their localhost traffic, it should still be sent back into that docker container.
                hostname = clientReq.remoteIpAddress;
                // We don't update the host header - from the POV of the target, it's still localhost traffic.
            }
            if (this.forwarding) {
                const { targetHost, updateHostHeader } = this.forwarding;
                if (!targetHost.includes('/')) {
                    // We're forwarding to a bare hostname
                    [hostname, port] = targetHost.split(':');
                }
                else {
                    // We're forwarding to a fully specified URL; override the host etc, but never the path.
                    ({ protocol, hostname, port } = url.parse(targetHost));
                }
                const hostHeaderName = isH2Downstream ? ':authority' : 'host';
                if (updateHostHeader === undefined || updateHostHeader === true) {
                    // If updateHostHeader is true, or just not specified, match the new target
                    headers[hostHeaderName] = hostname + (port ? `:${port}` : '');
                }
                else if (updateHostHeader) {
                    // If it's an explicit custom value, use that directly.
                    headers[hostHeaderName] = updateHostHeader;
                } // Otherwise: falsey means don't touch it.
            }
            // Check if this request is a request loop:
            if ((0, socket_util_1.isSocketLoop)(this.outgoingSockets, clientReq.socket)) {
                throw new Error((0, common_tags_1.oneLine) `
                Passthrough loop detected. This probably means you're sending a request directly
                to a passthrough endpoint, which is forwarding it to the target URL, which is a
                passthrough endpoint, which is forwarding it to the target URL, which is a
                passthrough endpoint...` +
                    '\n\n' + (0, common_tags_1.oneLine) `
                You should either explicitly mock a response for this URL (${reqUrl}), or use
                the server as a proxy, instead of making requests to it directly.
            `);
            }
            // Override the request details, if a transform or callback is specified:
            let reqBodyOverride;
            let headersManuallyModified = false;
            if (this.transformRequest) {
                const { replaceMethod, updateHeaders, replaceHeaders, replaceBody, replaceBodyFromFile, updateJsonBody } = this.transformRequest;
                if (replaceMethod) {
                    method = replaceMethod;
                }
                if (updateHeaders) {
                    headers = Object.assign(Object.assign({}, headers), updateHeaders);
                    headersManuallyModified = true;
                }
                else if (replaceHeaders) {
                    headers = Object.assign({}, replaceHeaders);
                    headersManuallyModified = true;
                }
                if (replaceBody) {
                    // Note that we're replacing the body without actually waiting for the real one, so
                    // this can result in sending a request much more quickly!
                    reqBodyOverride = (0, buffer_utils_1.asBuffer)(replaceBody);
                }
                else if (replaceBodyFromFile) {
                    reqBodyOverride = yield (0, fs_1.readFile)(replaceBodyFromFile, null);
                }
                else if (updateJsonBody) {
                    const { body: realBody } = yield (0, request_utils_1.waitForCompletedRequest)(clientReq);
                    if ((yield realBody.getJson()) === undefined) {
                        throw new Error("Can't transform non-JSON request body");
                    }
                    const updatedBody = _.mergeWith(yield realBody.getJson(), updateJsonBody, (_oldValue, newValue) => {
                        // We want to remove values with undefines, but Lodash ignores
                        // undefined return values here. Fortunately, JSON.stringify
                        // ignores Symbols, omitting them from the result.
                        if (newValue === undefined)
                            return OMIT_SYMBOL;
                    });
                    reqBodyOverride = (0, buffer_utils_1.asBuffer)(JSON.stringify(updatedBody));
                }
                if (reqBodyOverride) {
                    // We always re-encode the body to match the resulting content-encoding header:
                    reqBodyOverride = yield (0, http_encoding_1.encodeBuffer)(reqBodyOverride, (headers['content-encoding'] || ''), { level: 1 });
                    headers['content-length'] = getCorrectContentLength(reqBodyOverride, clientReq.headers, (updateHeaders && updateHeaders['content-length'] !== undefined)
                        ? headers // Iff you replaced the content length
                        : replaceHeaders);
                }
                headers = dropUndefinedValues(headers);
            }
            else if (this.beforeRequest) {
                const completedRequest = yield (0, request_utils_1.waitForCompletedRequest)(clientReq);
                const modifiedReq = yield this.beforeRequest(Object.assign(Object.assign({}, completedRequest), { headers: _.clone(completedRequest.headers) }));
                if (modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.response) {
                    if (modifiedReq.response === 'close') {
                        const socket = clientReq.socket;
                        socket.end();
                        throw new AbortError('Connection closed (intentionally)');
                    }
                    else {
                        // The callback has provided a full response: don't passthrough at all, just use it.
                        writeResponseFromCallback(modifiedReq.response, clientRes);
                        return;
                    }
                }
                method = (modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.method) || method;
                reqUrl = (modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.url) || reqUrl;
                headers = (modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.headers) || headers;
                Object.assign(headers, isH2Downstream
                    ? getCorrectPseudoheaders(reqUrl, clientReq.headers, modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.headers)
                    : { 'host': getCorrectHost(reqUrl, clientReq.headers, modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.headers) });
                headersManuallyModified = !!(modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.headers);
                validateCustomHeaders(completedRequest.headers, modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.headers, OVERRIDABLE_REQUEST_PSEUDOHEADERS // These are handled by getCorrectPseudoheaders above
                );
                if (modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.json) {
                    headers['content-type'] = 'application/json';
                    reqBodyOverride = (0, buffer_utils_1.asBuffer)(JSON.stringify(modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.json));
                }
                else {
                    reqBodyOverride = getCallbackResultBody(modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.body);
                }
                if (reqBodyOverride !== undefined) {
                    headers['content-length'] = getCorrectContentLength(reqBodyOverride, clientReq.headers, modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.headers);
                }
                headers = dropUndefinedValues(headers);
                // Reparse the new URL, if necessary
                if (modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.url) {
                    if (!(0, request_utils_1.isAbsoluteUrl)(modifiedReq === null || modifiedReq === void 0 ? void 0 : modifiedReq.url))
                        throw new Error("Overridden request URLs must be absolute");
                    ({ protocol, hostname, port, path } = url.parse(reqUrl));
                }
            }
            const hostWithPort = `${hostname}:${port}`;
            // Ignore cert errors if the host+port or whole hostname is whitelisted
            const strictHttpsChecks = !_.includes(this.ignoreHostHttpsErrors, hostname) &&
                !_.includes(this.ignoreHostHttpsErrors, hostWithPort);
            // Use a client cert if it's listed for the host+port or whole hostname
            const clientCert = this.clientCertificateHostMap[hostWithPort] ||
                this.clientCertificateHostMap[hostname] ||
                {};
            const trustedCerts = yield this.trustedCACertificates();
            const caConfig = trustedCerts
                ? { ca: trustedCerts }
                : {};
            // We only do H2 upstream for HTTPS. Http2-wrapper doesn't support H2C, it's rarely used
            // and we can't use ALPN to detect HTTP/2 support cleanly.
            let shouldTryH2Upstream = isH2Downstream && protocol === 'https:';
            const effectivePort = !!port
                ? parseInt(port, 10)
                : (protocol === 'https:' ? 443 : 80);
            let family;
            if (hostname === 'localhost') {
                // Annoying special case: some localhost servers listen only on either ipv4 or ipv6.
                // Very specific situation, but a very common one for development use.
                // We need to work out which one family is, as Node sometimes makes bad choices.
                if (yield (0, socket_util_1.isLocalPortActive)('::1', effectivePort))
                    family = 6;
                else
                    family = 4;
            }
            // Remote clients might configure a passthrough rule with a parameter reference for the proxy,
            // delegating proxy config to the admin server. That's fine initially, but you can't actually
            // handle a request in that case - make sure our proxyConfig is always dereferenced before use.
            const proxySettingSource = (0, rule_parameters_1.assertParamDereferenced)(this.proxyConfig);
            // Mirror the keep-alive-ness of the incoming request in our outgoing request
            const agent = yield (0, http_agents_1.getAgent)({
                protocol: (protocol || undefined),
                hostname: hostname,
                port: effectivePort,
                tryHttp2: shouldTryH2Upstream,
                keepAlive: (0, request_utils_1.shouldKeepAlive)(clientReq),
                proxySettingSource
            });
            if (agent && !('http2' in agent)) {
                // I.e. only use HTTP/2 if we're using an HTTP/2-compatible agent
                shouldTryH2Upstream = false;
            }
            let makeRequest = (shouldTryH2Upstream
                ? h2Client.auto
                // HTTP/1 + TLS
                : protocol === 'https:'
                    ? https.request
                    // HTTP/1 plaintext:
                    : http.request);
            if (isH2Downstream && shouldTryH2Upstream) {
                // We drop all incoming pseudoheaders, and regenerate them (except legally modified ones)
                headers = _.pickBy(headers, (value, key) => !key.toString().startsWith(':') ||
                    (headersManuallyModified &&
                        OVERRIDABLE_REQUEST_PSEUDOHEADERS.includes(key)));
            }
            else if (isH2Downstream && !shouldTryH2Upstream) {
                headers = (0, request_utils_1.h2HeadersToH1)(headers);
            }
            let serverReq;
            return new Promise((resolve, reject) => (() => __awaiter(this, void 0, void 0, function* () {
                serverReq = yield makeRequest(Object.assign(Object.assign({ protocol,
                    method,
                    hostname,
                    port,
                    family,
                    path,
                    headers, lookup: this.lookup(), 
                    // ^ Cast required to handle __promisify__ type hack in the official Node types
                    agent, 
                    // TLS options:
                    ciphers: passthrough_handling_1.MOCKTTP_UPSTREAM_CIPHERS, minVersion: strictHttpsChecks ? tls.DEFAULT_MIN_VERSION : 'TLSv1', rejectUnauthorized: strictHttpsChecks }, clientCert), caConfig), (serverRes) => (() => __awaiter(this, void 0, void 0, function* () {
                    serverRes.on('error', reject);
                    let serverStatusCode = serverRes.statusCode;
                    let serverStatusMessage = serverRes.statusMessage;
                    let serverHeaders = serverRes.headers;
                    let resBodyOverride;
                    if (isH2Downstream) {
                        serverHeaders = (0, request_utils_1.h1HeadersToH2)(serverHeaders);
                    }
                    if (this.transformResponse) {
                        const { replaceStatus, updateHeaders, replaceHeaders, replaceBody, replaceBodyFromFile, updateJsonBody } = this.transformResponse;
                        if (replaceStatus) {
                            serverStatusCode = replaceStatus;
                            serverStatusMessage = undefined; // Reset to default
                        }
                        if (updateHeaders) {
                            serverHeaders = Object.assign(Object.assign({}, serverHeaders), updateHeaders);
                        }
                        else if (replaceHeaders) {
                            serverHeaders = Object.assign({}, replaceHeaders);
                        }
                        if (replaceBody) {
                            // Note that we're replacing the body without actually waiting for the real one, so
                            // this can result in sending a request much more quickly!
                            resBodyOverride = (0, buffer_utils_1.asBuffer)(replaceBody);
                        }
                        else if (replaceBodyFromFile) {
                            resBodyOverride = yield (0, fs_1.readFile)(replaceBodyFromFile, null);
                        }
                        else if (updateJsonBody) {
                            const rawBody = yield (0, buffer_utils_1.streamToBuffer)(serverRes);
                            const realBody = (0, request_utils_1.buildBodyReader)(rawBody, serverRes.headers);
                            if ((yield realBody.getJson()) === undefined) {
                                throw new Error("Can't transform non-JSON response body");
                            }
                            const updatedBody = _.mergeWith(yield realBody.getJson(), updateJsonBody, (_oldValue, newValue) => {
                                // We want to remove values with undefines, but Lodash ignores
                                // undefined return values here. Fortunately, JSON.stringify
                                // ignores Symbols, omitting them from the result.
                                if (newValue === undefined)
                                    return OMIT_SYMBOL;
                            });
                            resBodyOverride = (0, buffer_utils_1.asBuffer)(JSON.stringify(updatedBody));
                        }
                        if (resBodyOverride) {
                            // We always re-encode the body to match the resulting content-encoding header:
                            resBodyOverride = yield (0, http_encoding_1.encodeBuffer)(resBodyOverride, (serverHeaders['content-encoding'] || ''));
                            serverHeaders['content-length'] = getCorrectContentLength(resBodyOverride, serverRes.headers, (updateHeaders && updateHeaders['content-length'] !== undefined)
                                ? serverHeaders // Iff you replaced the content length
                                : replaceHeaders, method === 'HEAD' // HEAD responses are allowed mismatched content-length
                            );
                        }
                        serverHeaders = dropUndefinedValues(serverHeaders);
                    }
                    else if (this.beforeResponse) {
                        let modifiedRes;
                        let body;
                        body = yield (0, buffer_utils_1.streamToBuffer)(serverRes);
                        const cleanHeaders = (0, request_utils_1.cleanUpHeaders)(serverHeaders);
                        modifiedRes = yield this.beforeResponse({
                            id: clientReq.id,
                            statusCode: serverStatusCode,
                            statusMessage: serverRes.statusMessage,
                            headers: _.clone(cleanHeaders),
                            body: (0, request_utils_1.buildBodyReader)(body, serverHeaders)
                        });
                        if (modifiedRes === 'close') {
                            // Dump the real response data and kill the client socket:
                            serverRes.resume();
                            clientRes.socket.end();
                            throw new AbortError('Connection closed (intentionally)');
                        }
                        validateCustomHeaders(cleanHeaders, modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.headers);
                        serverStatusCode = (modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.statusCode) ||
                            (modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.status) ||
                            serverStatusCode;
                        serverStatusMessage = (modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.statusMessage) ||
                            serverStatusMessage;
                        serverHeaders = (modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.headers) || serverHeaders;
                        if (modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.json) {
                            serverHeaders['content-type'] = 'application/json';
                            resBodyOverride = (0, buffer_utils_1.asBuffer)(JSON.stringify(modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.json));
                        }
                        else {
                            resBodyOverride = getCallbackResultBody(modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.body);
                        }
                        if (resBodyOverride !== undefined) {
                            serverHeaders['content-length'] = getCorrectContentLength(resBodyOverride, serverRes.headers, modifiedRes === null || modifiedRes === void 0 ? void 0 : modifiedRes.headers, method === 'HEAD' // HEAD responses are allowed mismatched content-length
                            );
                        }
                        else {
                            // If you don't specify a body override, we need to use the real
                            // body anyway, because as we've read it already streaming it to
                            // the response won't work
                            resBodyOverride = body;
                        }
                        serverHeaders = dropUndefinedValues(serverHeaders);
                    }
                    Object.keys(serverHeaders).forEach((header) => {
                        const headerValue = serverHeaders[header];
                        if (headerValue === undefined ||
                            header === http2.sensitiveHeaders ||
                            header === ':status' // H2 status gets set by writeHead below
                        )
                            return;
                        try {
                            clientRes.setHeader(header, headerValue);
                        }
                        catch (e) {
                            // A surprising number of real sites have slightly invalid headers
                            // (e.g. extra spaces). If we hit any, we just drop that header
                            // and print a warning.
                            console.log(`Error setting header on passthrough response: ${((0, error_1.isErrorLike)(e) && e.message) || e}`);
                        }
                    });
                    clientRes.writeHead(serverStatusCode, serverStatusMessage);
                    if (resBodyOverride) {
                        // Return the override data to the client:
                        clientRes.end(resBodyOverride);
                        // Dump the real response data:
                        serverRes.resume();
                        resolve();
                    }
                    else {
                        serverRes.pipe(clientRes);
                        serverRes.once('end', resolve);
                    }
                }))().catch(reject));
                serverReq.once('socket', (socket) => {
                    // This event can fire multiple times for keep-alive sockets, which are used to
                    // make multiple requests. If/when that happens, we don't need more event listeners.
                    if (this.outgoingSockets.has(socket))
                        return;
                    // Add this port to our list of active ports, once it's connected (before then it has no port)
                    if (socket.connecting) {
                        socket.once('connect', () => {
                            this.outgoingSockets.add(socket);
                        });
                    }
                    else if (socket.localPort !== undefined) {
                        this.outgoingSockets.add(socket);
                    }
                    // Remove this port from our list of active ports when it's closed
                    // This is called for both clean closes & errors.
                    socket.once('close', () => this.outgoingSockets.delete(socket));
                });
                if (reqBodyOverride) {
                    clientReq.body.asStream().resume(); // Dump any remaining real request body
                    if (reqBodyOverride.length > 0)
                        serverReq.end(reqBodyOverride);
                    else
                        serverReq.end(); // http2-wrapper fails given an empty buffer for methods that aren't allowed a body
                }
                else {
                    // asStream includes all content, including the body before this call
                    const reqBodyStream = clientReq.body.asStream();
                    reqBodyStream.pipe(serverReq);
                    reqBodyStream.on('error', () => serverReq.abort());
                }
                // If the downstream connection aborts, before the response has been completed,
                // we also abort the upstream connection. Important to avoid unnecessary connections,
                // and to correctly proxy client connection behaviour to the upstream server.
                function abortUpstream() {
                    serverReq.abort();
                }
                clientReq.on('aborted', abortUpstream);
                clientRes.once('finish', () => clientReq.removeListener('aborted', abortUpstream));
                serverReq.on('error', (e) => {
                    var _a;
                    if (serverReq.aborted)
                        return;
                    // Tag responses, so programmatic examination can react to this
                    // event, without having to parse response data or similar.
                    const tlsAlertMatch = /SSL alert number (\d+)/.exec((_a = e.message) !== null && _a !== void 0 ? _a : '');
                    if (tlsAlertMatch) {
                        clientRes.tags.push('passthrough-tls-error:ssl-alert-' + tlsAlertMatch[1]);
                    }
                    clientRes.tags.push('passthrough-error:' + e.code);
                    if (e.code === 'ECONNRESET') {
                        // The upstream socket closed: forcibly close the downstream stream to match
                        const socket = clientReq.socket;
                        socket.destroy();
                        reject(new AbortError('Upstream connection was reset'));
                    }
                    else {
                        e.statusCode = 502;
                        e.statusMessage = 'Error communicating with upstream server';
                        reject(e);
                    }
                });
                // We always start upstream connections *immediately*. This might be less efficient, but it
                // ensures that we're accurately mirroring downstream, which has indeed already connected.
                serverReq.flushHeaders();
                // For similar reasons, we don't want any buffering on outgoing data at all if possible:
                serverReq.setNoDelay(true);
            }))().catch((e) => {
                // Catch otherwise-unhandled sync or async errors in the above promise:
                if (serverReq)
                    serverReq.destroy();
                clientRes.tags.push('passthrough-error:' + e.code);
                reject(e);
            }));
        });
    }
    /**
     * @internal
     */
    static deserialize(data, channel, ruleParams) {
        var _a, _b, _c, _d, _e, _f;
        let beforeRequest;
        if (data.hasBeforeRequestCallback) {
            beforeRequest = (req) => __awaiter(this, void 0, void 0, function* () {
                const result = (0, serialization_1.withDeserializedBodyBuffer)(yield channel.request('beforeRequest', {
                    args: [(0, serialization_1.withSerializedBodyReader)(req)]
                }));
                if (result.response && typeof result.response !== 'string') {
                    result.response = (0, serialization_1.withDeserializedBodyBuffer)(result.response);
                }
                return result;
            });
        }
        let beforeResponse;
        if (data.hasBeforeResponseCallback) {
            beforeResponse = (res) => __awaiter(this, void 0, void 0, function* () {
                const callbackResult = yield channel.request('beforeResponse', {
                    args: [(0, serialization_1.withSerializedBodyReader)(res)]
                });
                if (callbackResult && typeof callbackResult !== 'string') {
                    return (0, serialization_1.withDeserializedBodyBuffer)(callbackResult);
                }
                else {
                    return callbackResult;
                }
            });
        }
        return new PassThroughHandler(Object.assign(Object.assign({ beforeRequest,
            beforeResponse, proxyConfig: (0, serialization_1.deserializeProxyConfig)(data.proxyConfig, channel, ruleParams), transformRequest: Object.assign(Object.assign(Object.assign(Object.assign({}, data.transformRequest), (((_a = data.transformRequest) === null || _a === void 0 ? void 0 : _a.replaceBody) !== undefined ? {
                replaceBody: (0, serialization_1.deserializeBuffer)(data.transformRequest.replaceBody)
            } : {})), (((_b = data.transformRequest) === null || _b === void 0 ? void 0 : _b.updateHeaders) !== undefined ? {
                updateHeaders: mapOmitToUndefined(JSON.parse(data.transformRequest.updateHeaders))
            } : {})), (((_c = data.transformRequest) === null || _c === void 0 ? void 0 : _c.updateJsonBody) !== undefined ? {
                updateJsonBody: mapOmitToUndefined(JSON.parse(data.transformRequest.updateJsonBody))
            } : {})), transformResponse: Object.assign(Object.assign(Object.assign(Object.assign({}, data.transformResponse), (((_d = data.transformResponse) === null || _d === void 0 ? void 0 : _d.replaceBody) !== undefined ? {
                replaceBody: (0, serialization_1.deserializeBuffer)(data.transformResponse.replaceBody)
            } : {})), (((_e = data.transformResponse) === null || _e === void 0 ? void 0 : _e.updateHeaders) !== undefined ? {
                updateHeaders: mapOmitToUndefined(JSON.parse(data.transformResponse.updateHeaders))
            } : {})), (((_f = data.transformResponse) === null || _f === void 0 ? void 0 : _f.updateJsonBody) !== undefined ? {
                updateJsonBody: mapOmitToUndefined(JSON.parse(data.transformResponse.updateJsonBody))
            } : {})) }, data.forwardToLocation ? {
            forwarding: { targetHost: data.forwardToLocation }
        } : {}), { forwarding: data.forwarding, lookupOptions: data.lookupOptions, ignoreHostHttpsErrors: data.ignoreHostCertificateErrors, trustAdditionalCAs: data.extraCACertificates, clientCertificateHostMap: _.mapValues(data.clientCertificateHostMap, ({ pfx, passphrase }) => ({ pfx: (0, serialization_1.deserializeBuffer)(pfx), passphrase })) }));
    }
}
exports.PassThroughHandler = PassThroughHandler;
class CloseConnectionHandler extends request_handler_definitions_1.CloseConnectionHandlerDefinition {
    handle(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const socket = request.socket;
            socket.end();
            throw new AbortError('Connection closed (intentionally)');
        });
    }
}
exports.CloseConnectionHandler = CloseConnectionHandler;
class TimeoutHandler extends request_handler_definitions_1.TimeoutHandlerDefinition {
    handle() {
        return __awaiter(this, void 0, void 0, function* () {
            // Do nothing, leaving the socket open but never sending a response.
            return new Promise(() => { });
        });
    }
}
exports.TimeoutHandler = TimeoutHandler;
exports.HandlerLookup = {
    'simple': SimpleHandler,
    'callback': CallbackHandler,
    'stream': StreamHandler,
    'file': FileHandler,
    'passthrough': PassThroughHandler,
    'close-connection': CloseConnectionHandler,
    'timeout': TimeoutHandler
};
//# sourceMappingURL=request-handlers.js.map