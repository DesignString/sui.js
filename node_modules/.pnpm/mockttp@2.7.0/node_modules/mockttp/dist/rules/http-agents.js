"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAgent = void 0;
const http = require("http");
const https = require("https");
const ProxyAgent = require("@httptoolkit/proxy-agent");
const util_1 = require("../util/util");
const proxy_config_1 = require("./proxy-config");
const KeepAliveAgents = util_1.isNode
    ? {
        'http:': new http.Agent({
            keepAlive: true
        }),
        'https:': new https.Agent({
            keepAlive: true
        })
    } : {};
function getAgent({ protocol, hostname, port, tryHttp2, keepAlive, proxySettingSource }) {
    return __awaiter(this, void 0, void 0, function* () {
        const proxySetting = yield (0, proxy_config_1.getProxySetting)(proxySettingSource, { hostname });
        if (proxySetting === null || proxySetting === void 0 ? void 0 : proxySetting.proxyUrl) {
            // If there's a (non-empty) proxy configured, use it. We require non-empty because empty strings
            // will fall back to detecting from the environment, which is likely to behave unexpectedly.
            if (!(0, proxy_config_1.matchesNoProxy)(hostname, port, proxySetting.noProxy)) {
                // We notably ignore HTTP/2 upstream in this case: it's complicated to mix that up with proxying
                // so for now we ignore it entirely.
                return new ProxyAgent(proxySetting.proxyUrl);
            }
        }
        if (tryHttp2 && (protocol === 'https:' || protocol === 'wss:')) {
            // H2 wrapper takes multiple agents, uses the appropriate one for the detected protocol.
            // We notably never use H2 upstream for plaintext, it's rare and we can't use ALPN to detect it.
            return { https: KeepAliveAgents['https:'], http2: undefined };
        }
        else if (keepAlive && protocol !== 'wss:' && protocol !== 'ws:') {
            // HTTP/1.1 or HTTP/1 with explicit keep-alive
            return KeepAliveAgents[protocol || 'http:'];
        }
        else {
            // HTTP/1 without KA - just send the request with no agent
            return undefined;
        }
    });
}
exports.getAgent = getAgent;
//# sourceMappingURL=http-agents.js.map