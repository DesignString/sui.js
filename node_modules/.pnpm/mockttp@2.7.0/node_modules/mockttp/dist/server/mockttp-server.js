"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockttpServer = void 0;
const url = require("url");
const tls = require("tls");
const events_1 = require("events");
const portfinder = require("portfinder");
const connect = require("connect");
const uuid_1 = require("uuid");
const cors = require("cors");
const now = require("performance-now");
const _ = require("lodash");
const mockttp_1 = require("../mockttp");
const request_rule_1 = require("../rules/requests/request-rule");
const mocked_endpoint_1 = require("./mocked-endpoint");
const http_combo_server_1 = require("./http-combo-server");
const promise_1 = require("../util/promise");
const error_1 = require("../util/error");
const request_utils_1 = require("../util/request-utils");
const request_handlers_1 = require("../rules/requests/request-handlers");
const websocket_rule_1 = require("../rules/websockets/websocket-rule");
const websocket_handlers_1 = require("../rules/websockets/websocket-handlers");
/**
 * A in-process Mockttp implementation. This starts servers on the local machine in the
 * current process, and exposes methods to directly manage them.
 *
 * This class does not work in browsers, as it expects to be able to start HTTP servers.
 */
class MockttpServer extends mockttp_1.AbstractMockttp {
    constructor(options = {}) {
        var _a, _b;
        super(options);
        this.requestRules = [];
        this.webSocketRules = [];
        this.setRequestRules = (...ruleData) => {
            this.requestRules.forEach(r => r.dispose());
            this.requestRules = ruleData.map((ruleDatum) => new request_rule_1.RequestRule(ruleDatum));
            return Promise.resolve(this.requestRules.map(r => new mocked_endpoint_1.ServerMockedEndpoint(r)));
        };
        this.addRequestRules = (...ruleData) => {
            return Promise.resolve(ruleData.map((ruleDatum) => {
                const rule = new request_rule_1.RequestRule(ruleDatum);
                this.requestRules.push(rule);
                return new mocked_endpoint_1.ServerMockedEndpoint(rule);
            }));
        };
        this.setFallbackRequestRule = (ruleDatum) => __awaiter(this, void 0, void 0, function* () {
            if (this.fallbackRequestRule)
                throw new Error('Only one fallback request rule can be registered at any time');
            const hasNoMatchers = ruleDatum.matchers.length === 0 || (ruleDatum.matchers.length === 1 &&
                ruleDatum.matchers[0].type === 'wildcard');
            if (!hasNoMatchers)
                throw new Error('Fallback request rules cannot include specific matching configuration');
            this.fallbackRequestRule = new request_rule_1.RequestRule(ruleDatum);
            return Promise.resolve(new mocked_endpoint_1.ServerMockedEndpoint(this.fallbackRequestRule));
        });
        this.setWebSocketRules = (...ruleData) => {
            this.webSocketRules.forEach(r => r.dispose());
            this.webSocketRules = ruleData.map((ruleDatum) => new websocket_rule_1.WebSocketRule(ruleDatum));
            return Promise.resolve(this.webSocketRules.map(r => new mocked_endpoint_1.ServerMockedEndpoint(r)));
        };
        this.addWebSocketRules = (...ruleData) => {
            return Promise.resolve(ruleData.map((ruleDatum) => {
                const rule = new websocket_rule_1.WebSocketRule(ruleDatum);
                this.webSocketRules.push(rule);
                return new mocked_endpoint_1.ServerMockedEndpoint(rule);
            }));
        };
        this.initialDebugSetting = this.debug;
        this.httpsOptions = options.https;
        this.isHttp2Enabled = (_a = options.http2) !== null && _a !== void 0 ? _a : 'fallback';
        this.maxBodySize = (_b = options.maxBodySize) !== null && _b !== void 0 ? _b : Infinity;
        this.eventEmitter = new events_1.EventEmitter();
        this.defaultWsHandler = new websocket_handlers_1.PassThroughWebSocketHandler({
            // Support the old (now deprecated) websocket certificate whitelist for default
            // proxying only. Manually added rules get configured individually.
            ignoreHostCertificateErrors: this.ignoreWebsocketHostCertificateErrors
        });
        this.app = connect();
        if (this.corsOptions) {
            if (this.debug)
                console.log('Enabling CORS');
            const corsOptions = this.corsOptions === true
                ? { methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'] }
                : this.corsOptions;
            this.app.use(cors(corsOptions));
        }
        this.app.use(this.handleRequest.bind(this));
    }
    start(portParam = { startPort: 8000, endPort: 65535 }) {
        return __awaiter(this, void 0, void 0, function* () {
            const port = _.isNumber(portParam)
                ? portParam
                : yield portfinder.getPortPromise({
                    port: portParam.startPort,
                    stopPort: portParam.endPort
                });
            if (this.debug)
                console.log(`Starting mock server on port ${port}`);
            this.server = yield (0, http_combo_server_1.createComboServer)({
                debug: this.debug,
                https: this.httpsOptions,
                http2: this.isHttp2Enabled,
            }, this.app, this.announceTlsErrorAsync.bind(this));
            this.server.listen(port);
            // Handle & report client request errors
            this.server.on('clientError', this.handleInvalidHttp1Request.bind(this));
            this.server.on('sessionError', this.handleInvalidHttp2Request.bind(this));
            // Track the socket of HTTP/2 sessions, for error reporting later:
            this.server.on('session', (session) => {
                session.on('connect', (session, socket) => {
                    session.initialSocket = socket;
                });
            });
            this.server.on('upgrade', this.handleWebSocket.bind(this));
            return new Promise((resolve, reject) => {
                this.server.on('listening', resolve);
                this.server.on('error', (e) => {
                    // Although we try to pick a free port, we may have race conditions, if something else
                    // takes the same port at the same time. If you haven't explicitly picked a port, and
                    // we do have a collision, simply try again.
                    if (e.code === 'EADDRINUSE' && !_.isNumber(portParam)) {
                        if (this.debug)
                            console.log('Address in use, retrying...');
                        // Destroy just in case there is something that needs cleanup here. Catch because most
                        // of the time this will error with 'Server is not running'.
                        this.server.destroy().catch(() => { });
                        resolve(this.start());
                    }
                    else {
                        reject(e);
                    }
                });
            });
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Stopping server at ${this.url}`);
            if (this.server)
                yield this.server.destroy();
            this.reset();
        });
    }
    enableDebug() {
        this.debug = true;
    }
    reset() {
        var _a;
        this.requestRules.forEach(r => r.dispose());
        this.requestRules = [];
        (_a = this.fallbackRequestRule) === null || _a === void 0 ? void 0 : _a.dispose();
        this.fallbackRequestRule = undefined;
        this.webSocketRules.forEach(r => r.dispose());
        this.webSocketRules = [];
        this.debug = this.initialDebugSetting;
    }
    get address() {
        if (!this.server)
            throw new Error('Cannot get address before server is started');
        return this.server.address();
    }
    get url() {
        if (!this.server)
            throw new Error('Cannot get url before server is started');
        if (this.httpsOptions) {
            return "https://localhost:" + this.port;
        }
        else {
            return "http://localhost:" + this.port;
        }
    }
    get port() {
        if (!this.server)
            throw new Error('Cannot get port before server is started');
        return this.address.port;
    }
    getMockedEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            return [
                ...this.requestRules.map(r => new mocked_endpoint_1.ServerMockedEndpoint(r)),
                ...this.webSocketRules.map(r => new mocked_endpoint_1.ServerMockedEndpoint(r))
            ];
        });
    }
    getPendingEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            const withPendingPromises = (yield this.getMockedEndpoints())
                .map((endpoint) => __awaiter(this, void 0, void 0, function* () {
                return ({
                    endpoint,
                    isPending: yield endpoint.isPending()
                });
            }));
            const withPending = yield Promise.all(withPendingPromises);
            return withPending.filter(wp => wp.isPending).map(wp => wp.endpoint);
        });
    }
    getRuleParameterKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return []; // Local servers never have rule parameters defined
        });
    }
    on(event, callback) {
        this.eventEmitter.on(event, callback);
        return Promise.resolve();
    }
    announceInitialRequestAsync(request) {
        setImmediate(() => {
            const initiatedReq = (0, request_utils_1.buildInitiatedRequest)(request);
            this.eventEmitter.emit('request-initiated', Object.assign(initiatedReq, {
                timingEvents: _.clone(initiatedReq.timingEvents),
                tags: _.clone(initiatedReq.tags)
            }));
        });
    }
    announceCompletedRequestAsync(request) {
        setImmediate(() => {
            (0, request_utils_1.waitForCompletedRequest)(request)
                .then((completedReq) => {
                this.eventEmitter.emit('request', Object.assign(completedReq, {
                    timingEvents: _.clone(completedReq.timingEvents),
                    tags: _.clone(completedReq.tags)
                }));
            })
                .catch(console.error);
        });
    }
    announceResponseAsync(response) {
        setImmediate(() => {
            (0, request_utils_1.waitForCompletedResponse)(response)
                .then((res) => {
                this.eventEmitter.emit('response', Object.assign(res, {
                    timingEvents: _.clone(res.timingEvents),
                    tags: _.clone(res.tags)
                }));
            })
                .catch(console.error);
        });
    }
    announceAbortAsync(request) {
        return __awaiter(this, void 0, void 0, function* () {
            setImmediate(() => {
                const req = (0, request_utils_1.buildAbortedRequest)(request);
                this.eventEmitter.emit('abort', Object.assign(req, {
                    timingEvents: _.clone(req.timingEvents),
                    tags: _.clone(req.tags)
                }));
            });
        });
    }
    announceTlsErrorAsync(socket, request) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ignore errors after TLS is setup, those are client errors
            if (socket instanceof tls.TLSSocket && socket.tlsSetupCompleted)
                return;
            setImmediate(() => {
                // We can get falsey but set hostname values - drop them
                if (!request.hostname)
                    delete request.hostname;
                if (this.debug)
                    console.warn(`TLS client error: ${JSON.stringify(request)}`);
                this.eventEmitter.emit('tls-client-error', request);
                this.eventEmitter.emit('tlsClientError', request);
            });
        });
    }
    announceClientErrorAsync(socket, error) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ignore errors before TLS is setup, those are TLS errors
            if (socket instanceof tls.TLSSocket &&
                !socket.tlsSetupCompleted &&
                error.errorCode !== 'ERR_HTTP2_ERROR' // Initial HTTP/2 errors are considered post-TLS
            )
                return;
            setImmediate(() => {
                if (this.debug)
                    console.warn(`Client error: ${JSON.stringify(error)}`);
                this.eventEmitter.emit('client-error', error);
            });
        });
    }
    preprocessRequest(req) {
        (0, request_utils_1.parseRequestBody)(req, { maxSize: this.maxBodySize });
        // Make req.url always absolute, if it isn't already, using the host header.
        // It might not be if this is a direct request, or if it's being transparently proxied.
        if (!(0, request_utils_1.isAbsoluteUrl)(req.url)) {
            req.protocol = req.headers[':scheme'] ||
                (req.socket.lastHopEncrypted ? 'https' : 'http');
            req.path = req.url;
            const host = req.headers[':authority'] || req.headers['host'];
            const absoluteUrl = `${req.protocol}://${host}${req.path}`;
            if (!req.headers[':path']) {
                req.url = new url.URL(absoluteUrl).toString();
            }
            else {
                // Node's HTTP/2 compat logic maps .url to headers[':path']. We want them to
                // diverge: .url should always be absolute, while :path may stay relative,
                // so we override the built-in getter & setter:
                Object.defineProperty(req, 'url', {
                    value: new url.URL(absoluteUrl).toString()
                });
            }
        }
        else {
            req.protocol = req.url.split('://', 1)[0];
            req.path = (0, request_utils_1.getPathFromAbsoluteUrl)(req.url);
        }
        const id = (0, uuid_1.v4)();
        const timingEvents = { startTime: Date.now(), startTimestamp: now() };
        const tags = [];
        return Object.assign(req, {
            id,
            remoteIpAddress: req.socket.remoteAddress,
            remotePort: req.socket.remotePort,
            timingEvents,
            tags
        });
    }
    handleRequest(rawRequest, rawResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = this.preprocessRequest(rawRequest);
            if (this.debug)
                console.log(`Handling request for ${rawRequest.url}`);
            let result = null;
            const abort = () => {
                if (result === null) {
                    result = 'aborted';
                    request.timingEvents.abortedTimestamp = now();
                    this.announceAbortAsync(request);
                }
            };
            request.once('aborted', abort);
            // In Node 16+ we don't get an abort event in many cases, just closes, but we know
            // it's aborted because the response is closed with no other result being set.
            rawResponse.once('close', () => setImmediate(abort));
            request.once('error', () => setImmediate(abort));
            this.announceInitialRequestAsync(request);
            const response = (0, request_utils_1.trackResponse)(rawResponse, request.timingEvents, request.tags, { maxSize: this.maxBodySize });
            response.id = request.id;
            response.on('error', (error) => {
                console.log('Response error:', this.debug ? error : error.message);
                abort();
            });
            try {
                let nextRulePromise = this.findMatchingRule(this.requestRules, request);
                // Async: once we know what the next rule is, ping a request event
                nextRulePromise
                    .then((rule) => rule ? rule.id : undefined)
                    .catch(() => undefined)
                    .then((ruleId) => {
                    request.matchedRuleId = ruleId;
                    this.announceCompletedRequestAsync(request);
                });
                let nextRule = yield nextRulePromise;
                if (nextRule) {
                    if (this.debug)
                        console.log(`Request matched rule: ${nextRule.explain()}`);
                    yield nextRule.handle(request, response, this.recordTraffic);
                }
                else if (this.fallbackRequestRule) {
                    yield this.fallbackRequestRule.handle(request, response, this.recordTraffic);
                }
                else {
                    yield this.sendUnmatchedRequestError(request, response);
                }
                result = result || 'responded';
            }
            catch (e) {
                if (e instanceof request_handlers_1.AbortError) {
                    abort();
                    if (this.debug) {
                        console.error("Failed to handle request due to abort:", e);
                    }
                }
                else {
                    console.error("Failed to handle request:", this.debug
                        ? e
                        : ((0, error_1.isErrorLike)(e) && e.message) || e);
                    // Do whatever we can to tell the client we broke
                    try {
                        response.writeHead(((0, error_1.isErrorLike)(e) && e.statusCode) || 500, ((0, error_1.isErrorLike)(e) && e.statusMessage) || 'Server error');
                    }
                    catch (e) { }
                    try {
                        response.end(((0, error_1.isErrorLike)(e) && e.toString()) || e);
                        result = result || 'responded';
                    }
                    catch (e) {
                        abort();
                    }
                }
            }
            if (result === 'responded') {
                this.announceResponseAsync(response);
            }
        });
    }
    handleWebSocket(rawRequest, socket, head) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Handling websocket for ${rawRequest.url}`);
            const request = this.preprocessRequest(rawRequest);
            socket.on('error', (error) => {
                console.log('Response error:', this.debug ? error : error.message);
                socket.destroy();
            });
            try {
                let nextRulePromise = this.findMatchingRule(this.webSocketRules, request);
                let nextRule = yield nextRulePromise;
                if (nextRule) {
                    if (this.debug)
                        console.log(`Websocket matched rule: ${nextRule.explain()}`);
                    yield nextRule.handle(request, socket, head, this.recordTraffic);
                }
                else {
                    // Unmatched requests get passed through untouched automatically. This exists for
                    // historical/backward-compat reasons, to match the initial WS implementation, and
                    // will probably be removed to match handleRequest in future.
                    yield this.defaultWsHandler.handle(request, socket, head);
                }
            }
            catch (e) {
                if (e instanceof request_handlers_1.AbortError) {
                    if (this.debug) {
                        console.error("Failed to handle websocket due to abort:", e);
                    }
                }
                else {
                    console.error("Failed to handle websocket:", this.debug
                        ? e
                        : ((0, error_1.isErrorLike)(e) && e.message) || e);
                    this.sendWebSocketErrorResponse(socket, e);
                }
            }
        });
    }
    findMatchingRule(rules, request) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Start all rules matching immediately
            const rulesMatches = rules
                .filter((r) => r.isComplete() !== true) // Skip all rules that are definitely completed
                .map((r) => ({ rule: r, match: r.matches(request) }));
            // Evaluate the matches one by one, and immediately use the first
            for (let { rule, match } of rulesMatches) {
                if ((yield match) && rule.isComplete() === false) {
                    // The first matching incomplete rule we find is the one we should use
                    return rule;
                }
            }
            // There are no incomplete & matching rules! One last option: if the last matching rule is
            // maybe-incomplete (i.e. default completion status but has seen >0 requests) then it should
            // match anyway. This allows us to add rules and have the last repeat indefinitely.
            const lastMatchingRule = (_a = _.last(yield (0, promise_1.filter)(rulesMatches, m => m.match))) === null || _a === void 0 ? void 0 : _a.rule;
            if (!lastMatchingRule || lastMatchingRule.isComplete())
                return undefined;
            // Otherwise, must be a rule with isComplete === null, i.e. no specific completion check:
            else
                return lastMatchingRule;
        });
    }
    getUnmatchedRequestExplanation(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestExplanation = yield this.explainRequest(request);
            if (this.debug)
                console.warn(`Unmatched request received: ${requestExplanation}`);
            return `No rules were found matching this request.
This request was: ${requestExplanation}

${(this.requestRules.length > 0 || this.webSocketRules.length > 0)
                ? `The configured rules are:
${this.requestRules.map((rule) => rule.explain()).join("\n")}
${this.webSocketRules.map((rule) => rule.explain()).join("\n")}
`
                : "There are no rules configured."}
${yield this.suggestRule(request)}`;
        });
    }
    sendUnmatchedRequestError(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            response.setHeader('Content-Type', 'text/plain');
            response.writeHead(503, "Request for unmocked endpoint");
            response.end(yield this.getUnmatchedRequestExplanation(request));
        });
    }
    sendWebSocketErrorResponse(socket, error) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (socket.writable) {
                socket.end('HTTP/1.1 500 Internal Server Error\r\n' +
                    '\r\n' +
                    ((0, error_1.isErrorLike)(error)
                        ? (_a = error.message) !== null && _a !== void 0 ? _a : error.toString()
                        : ''));
            }
            socket.destroy(error);
        });
    }
    explainRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let msg = `${request.method} request to ${request.url}`;
            let bodyText = yield request.body.asText();
            if (bodyText)
                msg += ` with body \`${bodyText}\``;
            if (!_.isEmpty(request.headers)) {
                msg += ` with headers:\n${JSON.stringify(request.headers, null, 2)}`;
            }
            return msg;
        });
    }
    suggestRule(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.suggestChanges)
                return '';
            let msg = "You can fix this by adding a rule to match this request, for example:\n";
            msg += `mockServer.for${_.startCase(request.method.toLowerCase())}("${request.path}")`;
            const contentType = request.headers['content-type'];
            let isFormRequest = !!contentType && contentType.indexOf("application/x-www-form-urlencoded") > -1;
            let formBody = yield request.body.asFormData().catch(() => undefined);
            if (isFormRequest && !!formBody) {
                msg += `.withForm(${JSON.stringify(formBody)})`;
            }
            msg += '.thenReply(200, "your response");';
            return msg;
        });
    }
    // Called on server clientError, e.g. if the client disconnects during initial
    // request data, or sends totally invalid gibberish. Only called for HTTP/1.1 errors.
    handleInvalidHttp1Request(error, socket) {
        if (socket.clientErrorInProgress) {
            // For subsequent errors on the same socket, accumulate packet data (linked to the socket)
            // so that the error (probably delayed until next tick) has it all to work with
            const previousPacket = socket.clientErrorInProgress.rawPacket;
            const newPacket = error.rawPacket;
            if (!newPacket || newPacket === previousPacket)
                return;
            if (previousPacket && previousPacket.length > 0) {
                if (previousPacket.equals(newPacket.slice(0, previousPacket.length))) {
                    // This is the same data, but more - update the client error data
                    socket.clientErrorInProgress.rawPacket = newPacket;
                }
                else {
                    // This is different data for the same socket, probably an overflow, append it
                    socket.clientErrorInProgress.rawPacket = Buffer.concat([
                        previousPacket,
                        newPacket
                    ]);
                }
            }
            else {
                // The first error had no data, we have data - use our data
                socket.clientErrorInProgress.rawPacket = newPacket;
            }
            return;
        }
        // We can get multiple errors for the same socket in rapid succession as the parser works,
        // so we store the initial buffer, wait a tick, and then reply/report the accumulated
        // buffer from all errors together.
        socket.clientErrorInProgress = {
            // We use HTTP peeked data to catch extra data the parser sees due to httpolyglot peeking,
            // but which gets lost from the raw packet. If that data alone causes an error though
            // (e.g. Q as first char) then this packet data does get thrown! Eugh. In that case,
            // we need to avoid using both by accident, so we use just the non-peeked data instead.
            rawPacket: error.rawPacket === socket.__httpPeekedData
                ? undefined
                : error.rawPacket
        };
        setImmediate(() => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const errorCode = error.code;
            const isHeaderOverflow = errorCode === "HPE_HEADER_OVERFLOW";
            const commonParams = {
                id: (0, uuid_1.v4)(),
                tags: [`client-error:${error.code || 'UNKNOWN'}`],
                timingEvents: { startTime: Date.now(), startTimestamp: now() }
            };
            // Initially _httpMessage is undefined, until at least one request has been parsed.
            // Later it's set to the current ServerResponse, and then null when the socket is
            // detached, but never back to undefined. Avoids issues with using old peeked data
            // on subsequent requests within keep-alive connections.
            const isFirstRequest = socket._httpMessage === undefined;
            // HTTPolyglot's byte-peeking can sometimes lose the initial byte from the parser's
            // exposed buffer. If that's happened, we need to get it back:
            const rawPacket = Buffer.concat([
                isFirstRequest && socket.__httpPeekedData,
                (_a = socket.clientErrorInProgress) === null || _a === void 0 ? void 0 : _a.rawPacket
            ].filter((data) => !!data));
            // For packets where we get more than just httpolyglot-peeked data, guess-parse them:
            const parsedRequest = rawPacket.byteLength > 1
                ? (0, request_utils_1.tryToParseHttp)(rawPacket, socket)
                : {};
            if (isHeaderOverflow)
                commonParams.tags.push('header-overflow');
            const request = Object.assign(Object.assign({}, commonParams), { httpVersion: parsedRequest.httpVersion, method: parsedRequest.method, protocol: parsedRequest.protocol, url: parsedRequest.url, path: parsedRequest.path, headers: parsedRequest.headers || {}, remoteIpAddress: socket.remoteAddress, remotePort: socket.remotePort });
            let response;
            if (socket.writable) {
                response = Object.assign(Object.assign({}, commonParams), { headers: { 'Connection': 'close' }, statusCode: isHeaderOverflow
                        ? 431
                        : 400, statusMessage: isHeaderOverflow
                        ? "Request Header Fields Too Large"
                        : "Bad Request", body: (0, request_utils_1.buildBodyReader)(Buffer.from([]), {}) });
                const responseBuffer = Buffer.from(`HTTP/1.1 ${response.statusCode} ${response.statusMessage}\r\n` +
                    "Connection: close\r\n\r\n", 'ascii');
                // Wait for the write to complete before we destroy() below
                yield new Promise((resolve) => socket.write(responseBuffer, resolve));
                commonParams.timingEvents.headersSentTimestamp = now();
                commonParams.timingEvents.responseSentTimestamp = now();
            }
            else {
                response = 'aborted';
                commonParams.timingEvents.abortedTimestamp = now();
            }
            this.announceClientErrorAsync(socket, { errorCode, request, response });
            socket.destroy(error);
        }));
    }
    // Handle HTTP/2 client errors. This is a work in progress, but usefully reports
    // some of the most obvious cases.
    handleInvalidHttp2Request(error, session) {
        // Unlike with HTTP/1.1, we have no control of the actual handling of
        // the error here, so this is just a matter of announcing the error to subscribers.
        const socket = session.initialSocket;
        const isTLS = socket instanceof tls.TLSSocket;
        const isBadPreface = (error.errno === -903);
        this.announceClientErrorAsync(session.initialSocket, {
            errorCode: error.code,
            request: {
                id: (0, uuid_1.v4)(),
                tags: [
                    `client-error:${error.code || 'UNKNOWN'}`,
                    ...(isBadPreface ? ['client-error:bad-preface'] : [])
                ],
                httpVersion: '2',
                // Best guesses:
                timingEvents: { startTime: Date.now(), startTimestamp: now() },
                protocol: isTLS ? "https" : "http",
                url: isTLS ? `https://${socket.servername // Use the hostname from SNI
                }/` : undefined,
                // Unknowable:
                path: undefined,
                headers: {}
            },
            response: 'aborted' // These h2 errors get no app-level response, just a shutdown.
        });
    }
}
exports.MockttpServer = MockttpServer;
//# sourceMappingURL=mockttp-server.js.map