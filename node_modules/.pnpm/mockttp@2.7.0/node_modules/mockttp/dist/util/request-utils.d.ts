/// <reference types="node" />
import * as net from 'net';
import * as http from 'http';
import * as http2 from 'http2';
import { Headers, OngoingRequest, CompletedRequest, OngoingResponse, CompletedResponse, CompletedBody, TimingEvents, InitiatedRequest } from "../types";
export declare const isAbsoluteUrl: (url: string) => boolean;
export declare const isRelativeUrl: (url: string) => boolean;
export declare const isAbsoluteProtocollessUrl: (url: string) => boolean;
export declare const getUrlWithoutProtocol: (url: string) => string;
export declare const getPathFromAbsoluteUrl: (url: string) => string;
export declare const shouldKeepAlive: (req: OngoingRequest) => boolean;
export declare const setHeaders: (response: http.ServerResponse, headers: Headers) => void;
export declare function dropDefaultHeaders(response: OngoingResponse): void;
export declare function isHttp2(message: http.IncomingMessage | http2.Http2ServerRequest | http2.Http2ServerResponse | OngoingRequest | OngoingResponse): message is http2.Http2ServerRequest | http2.Http2ServerResponse;
export declare function h2HeadersToH1(h2Headers: Headers): Headers;
export declare function h1HeadersToH2(headers: Headers): Headers;
export declare const isMockttpBody: (body: any) => body is CompletedBody;
export declare const buildBodyReader: (body: Buffer, headers: Headers) => CompletedBody;
export declare const parseRequestBody: (req: http.IncomingMessage | http2.Http2ServerRequest, options: {
    maxSize: number;
}) => void;
/**
 * Translate from internal header representations (basically Node's header representations) to a
 * mildly more consistent & simplified model that we expose externally: numbers as strings, and
 * no sensitiveHeaders symbol for HTTP/2.
 */
export declare function cleanUpHeaders(headers: Headers): {};
/**
 * Build an initiated request: the external representation of a request
 * that's just started.
 */
export declare function buildInitiatedRequest(request: OngoingRequest): InitiatedRequest;
/**
 * Build an aborted request: the external representation of a request
 * that's been aborted.
 */
export declare function buildAbortedRequest(request: OngoingRequest): InitiatedRequest;
/**
 * Build a completed request: the external representation of a request
 * that's been completely received (but not necessarily replied to).
 */
export declare function waitForCompletedRequest(request: OngoingRequest): Promise<CompletedRequest>;
export declare function trackResponse(response: http.ServerResponse, timingEvents: TimingEvents, tags: string[], options: {
    maxSize: number;
}): OngoingResponse;
/**
 * Build a completed response: the external representation of a response
 * that's been completely written out and sent back to the client.
 */
export declare function waitForCompletedResponse(response: OngoingResponse): Promise<CompletedResponse>;
export declare function tryToParseHttp(input: Buffer, socket: net.Socket): PartiallyParsedHttpRequest;
declare type PartiallyParsedHttpRequest = {
    protocol?: string;
    httpVersion?: string;
    method?: string;
    url?: string;
    headers?: Headers;
    hostname?: string;
    path?: string;
};
export {};
