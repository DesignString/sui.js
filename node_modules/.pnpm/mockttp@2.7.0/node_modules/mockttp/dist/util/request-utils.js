"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryToParseHttp = exports.waitForCompletedResponse = exports.trackResponse = exports.waitForCompletedRequest = exports.buildAbortedRequest = exports.buildInitiatedRequest = exports.cleanUpHeaders = exports.parseRequestBody = exports.buildBodyReader = exports.isMockttpBody = exports.h1HeadersToH2 = exports.h2HeadersToH1 = exports.isHttp2 = exports.dropDefaultHeaders = exports.setHeaders = exports.shouldKeepAlive = exports.getPathFromAbsoluteUrl = exports.getUrlWithoutProtocol = exports.isAbsoluteProtocollessUrl = exports.isRelativeUrl = exports.isAbsoluteUrl = void 0;
const _ = require("lodash");
const tls_1 = require("tls");
const http2 = require("http2");
const stream = require("stream");
const querystring = require("querystring");
const now = require("performance-now");
const url = require("url");
const http_encoding_1 = require("http-encoding");
const util_1 = require("./util");
const buffer_utils_1 = require("./buffer-utils");
// Is this URL fully qualified?
// Note that this supports only HTTP - no websockets or anything else.
const isAbsoluteUrl = (url) => url.toLowerCase().startsWith('http://') ||
    url.toLowerCase().startsWith('https://');
exports.isAbsoluteUrl = isAbsoluteUrl;
const isRelativeUrl = (url) => url.startsWith('/');
exports.isRelativeUrl = isRelativeUrl;
const isAbsoluteProtocollessUrl = (url) => !(0, exports.isAbsoluteUrl)(url) && !(0, exports.isRelativeUrl)(url);
exports.isAbsoluteProtocollessUrl = isAbsoluteProtocollessUrl;
const getUrlWithoutProtocol = (url) => {
    return url.split('://', 2).slice(-1).join('');
};
exports.getUrlWithoutProtocol = getUrlWithoutProtocol;
const getPathFromAbsoluteUrl = (url) => {
    const pathIndex = (0, util_1.nthIndexOf)(url, '/', 3);
    if (pathIndex !== -1) {
        return url.slice(pathIndex);
    }
    else {
        return '';
    }
};
exports.getPathFromAbsoluteUrl = getPathFromAbsoluteUrl;
const shouldKeepAlive = (req) => req.httpVersion !== '1.0' &&
    req.headers['connection'] !== 'close' &&
    req.headers['proxy-connection'] !== 'close';
exports.shouldKeepAlive = shouldKeepAlive;
const setHeaders = (response, headers) => {
    Object.keys(headers).forEach((header) => {
        let value = headers[header];
        if (!value)
            return;
        response.setHeader(header, value);
    });
};
exports.setHeaders = setHeaders;
// If the user explicitly specifies headers, we tell Node not to handle them,
// so the user-defined headers are the full set.
function dropDefaultHeaders(response) {
    // Drop the default headers, so only the headers we explicitly configure are included
    [
        'connection',
        'content-length',
        'transfer-encoding',
        'date'
    ].forEach((defaultHeader) => response.removeHeader(defaultHeader));
}
exports.dropDefaultHeaders = dropDefaultHeaders;
function isHttp2(message) {
    var _a;
    return ('httpVersion' in message && !!((_a = message.httpVersion) === null || _a === void 0 ? void 0 : _a.startsWith('2'))) || // H2 request
        ('stream' in message && 'createPushResponse' in message); // H2 response
}
exports.isHttp2 = isHttp2;
function h2HeadersToH1(h2Headers) {
    const h1Headers = _.omitBy(h2Headers, (_value, key) => {
        return key === http2.sensitiveHeaders || key.toString().startsWith(':');
    });
    if (!h1Headers['host'] && h2Headers[':authority']) {
        h1Headers['host'] = h2Headers[':authority'];
    }
    if (_.isArray(h1Headers['cookie'])) {
        h1Headers['cookie'] = h1Headers['cookie'].join('; ');
    }
    return h1Headers;
}
exports.h2HeadersToH1 = h2HeadersToH1;
// Take from http2/util.js in Node itself
const HTTP2_ILLEGAL_HEADERS = [
    'connection',
    'upgrade',
    'host',
    'http2-settings',
    'keep-alive',
    'proxy-connection',
    'transfer-encoding'
];
function h1HeadersToH2(headers) {
    return _.omitBy(headers, (_value, key) => {
        return HTTP2_ILLEGAL_HEADERS.includes(key);
    });
}
exports.h1HeadersToH2 = h1HeadersToH2;
// Parse an in-progress request or response stream, i.e. where the body or possibly even the headers have
// not been fully received/sent yet.
const parseBodyStream = (bodyStream, maxSize, getHeaders) => {
    let bufferPromise = null;
    let completedBuffer = null;
    let body = {
        // Returns a stream for the full body, not the live streaming body.
        // Each call creates a new stream, which starts with the already seen
        // and buffered data, and then continues with the live stream, if active.
        // Listeners to this stream *must* be attached synchronously after this call.
        asStream() {
            return completedBuffer
                ? (0, buffer_utils_1.bufferToStream)(completedBuffer)
                : (0, buffer_utils_1.bufferThenStream)(body.asBuffer(), bodyStream);
        },
        asBuffer() {
            if (!bufferPromise) {
                bufferPromise = (0, buffer_utils_1.streamToBuffer)(bodyStream, maxSize);
                bufferPromise
                    .then((buffer) => completedBuffer = buffer)
                    .catch(() => { }); // If we get no body, completedBuffer stays null
            }
            return bufferPromise;
        },
        asDecodedBuffer() {
            return __awaiter(this, void 0, void 0, function* () {
                const buffer = yield body.asBuffer();
                return (0, http_encoding_1.decodeBuffer)(buffer, getHeaders()['content-encoding']);
            });
        },
        asText(encoding = 'utf8') {
            return body.asDecodedBuffer().then((b) => b.toString(encoding));
        },
        asJson() {
            return body.asText().then((t) => JSON.parse(t));
        },
        asFormData() {
            return body.asText().then((t) => querystring.parse(t));
        },
    };
    return body;
};
function runOrUndefined(func) {
    try {
        return func();
    }
    catch (_a) {
        return undefined;
    }
}
function runAsyncOrUndefined(func) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield func();
        }
        catch (_a) {
            return undefined;
        }
    });
}
const waitForBody = (body, headers) => __awaiter(void 0, void 0, void 0, function* () {
    const bufferBody = yield body.asBuffer();
    return (0, exports.buildBodyReader)(bufferBody, headers);
});
const isMockttpBody = (body) => {
    return body.hasOwnProperty('getDecodedBuffer');
};
exports.isMockttpBody = isMockttpBody;
const buildBodyReader = (body, headers) => {
    const completedBody = {
        buffer: body,
        getDecodedBuffer() {
            return __awaiter(this, void 0, void 0, function* () {
                return runAsyncOrUndefined(() => __awaiter(this, void 0, void 0, function* () {
                    return (0, buffer_utils_1.asBuffer)(yield (0, http_encoding_1.decodeBuffer)(this.buffer, headers['content-encoding']));
                }));
            });
        },
        getText() {
            return __awaiter(this, void 0, void 0, function* () {
                return runAsyncOrUndefined(() => __awaiter(this, void 0, void 0, function* () { return (yield this.getDecodedBuffer()).toString(); }));
            });
        },
        getJson() {
            return __awaiter(this, void 0, void 0, function* () {
                return runAsyncOrUndefined(() => __awaiter(this, void 0, void 0, function* () { return JSON.parse((yield completedBody.getText())); }));
            });
        },
        getFormData() {
            return __awaiter(this, void 0, void 0, function* () {
                return runAsyncOrUndefined(() => __awaiter(this, void 0, void 0, function* () {
                    const text = yield completedBody.getText();
                    return text ? querystring.parse(text) : undefined;
                }));
            });
        },
        // Deprecated sync properties, for backwards compat. Note that these do not
        // support new encodings, e.g. Brotli/Zstandard.
        get decodedBuffer() {
            return runOrUndefined(() => (0, http_encoding_1.decodeBufferSync)(this.buffer, headers['content-encoding']));
        },
        get text() {
            return runOrUndefined(() => this.decodedBuffer.toString('utf8'));
        },
        get json() {
            return runOrUndefined(() => JSON.parse(completedBody.text));
        },
        get formData() {
            return runOrUndefined(() => completedBody.text ? querystring.parse(completedBody.text) : undefined);
        }
    };
    return completedBody;
};
exports.buildBodyReader = buildBodyReader;
const parseRequestBody = (req, options) => {
    let transformedRequest = req;
    transformedRequest.body = parseBodyStream(req, options.maxSize, () => req.headers);
};
exports.parseRequestBody = parseRequestBody;
/**
 * Translate from internal header representations (basically Node's header representations) to a
 * mildly more consistent & simplified model that we expose externally: numbers as strings, and
 * no sensitiveHeaders symbol for HTTP/2.
 */
function cleanUpHeaders(headers) {
    return _.mapValues(_.omit(headers, ...(http2.sensitiveHeaders ? [http2.sensitiveHeaders] : [])), (headerValue) => _.isNumber(headerValue) ? headerValue.toString() : headerValue);
}
exports.cleanUpHeaders = cleanUpHeaders;
/**
 * Build an initiated request: the external representation of a request
 * that's just started.
 */
function buildInitiatedRequest(request) {
    return Object.assign(Object.assign({}, _.pick(request, 'id', 'matchedRuleId', 'protocol', 'httpVersion', 'method', 'url', 'path', 'remoteIpAddress', 'remotePort', 'hostname', 'headers', 'tags')), { headers: cleanUpHeaders(request.headers), timingEvents: request.timingEvents });
}
exports.buildInitiatedRequest = buildInitiatedRequest;
/**
 * Build an aborted request: the external representation of a request
 * that's been aborted.
 */
function buildAbortedRequest(request) {
    const requestData = buildInitiatedRequest(request);
    return Object.assign(requestData, {
        headers: cleanUpHeaders(request.headers),
        // Exists for backward compat: really Abort events should have no body at all
        body: (0, exports.buildBodyReader)(Buffer.alloc(0), {})
    });
}
exports.buildAbortedRequest = buildAbortedRequest;
/**
 * Build a completed request: the external representation of a request
 * that's been completely received (but not necessarily replied to).
 */
function waitForCompletedRequest(request) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = yield waitForBody(request.body, request.headers);
        request.timingEvents.bodyReceivedTimestamp = request.timingEvents.bodyReceivedTimestamp || now();
        const requestData = buildInitiatedRequest(request);
        return Object.assign(requestData, { body, headers: cleanUpHeaders(request.headers) });
    });
}
exports.waitForCompletedRequest = waitForCompletedRequest;
function trackResponse(response, timingEvents, tags, options) {
    let trackedResponse = response;
    if (!trackedResponse.getHeaders) {
        // getHeaders was added in 7.7. - if it's not available, polyfill it
        trackedResponse.getHeaders = function () { return this._headers; };
    }
    trackedResponse.timingEvents = timingEvents;
    trackedResponse.tags = tags;
    // Headers are sent when .writeHead or .write() are first called
    const trackingStream = new stream.PassThrough();
    const originalWriteHeader = trackedResponse.writeHead;
    const originalWrite = trackedResponse.write;
    const originalEnd = trackedResponse.end;
    trackedResponse.writeHead = function (...args) {
        if (!timingEvents.headersSentTimestamp) {
            timingEvents.headersSentTimestamp = now();
        }
        // HTTP/2 responses shouldn't have a status message:
        if (isHttp2(trackedResponse) && typeof args[1] === 'string') {
            args[1] = undefined;
        }
        return originalWriteHeader.apply(this, args);
    };
    const trackingWrite = function (...args) {
        trackingStream.write.apply(trackingStream, args);
        return originalWrite.apply(this, args);
    };
    trackedResponse.write = trackingWrite;
    trackedResponse.end = function (...args) {
        // We temporarily disable write tracking here, as .end
        // can call this.write, but that write should not be
        // tracked, or we'll get duplicate writes when trackingStream
        // calls it on itself too.
        trackedResponse.write = originalWrite;
        trackingStream.end.apply(trackingStream, args);
        let result = originalEnd.apply(this, args);
        trackedResponse.write = trackingWrite;
        return result;
    };
    trackedResponse.body = parseBodyStream(trackingStream, options.maxSize, () => trackedResponse.getHeaders());
    // Proxy errors (e.g. write-after-end) to the response, so they can be
    // handled elsewhere, rather than killing the process outright.
    trackingStream.on('error', (e) => trackedResponse.emit('error', e));
    return trackedResponse;
}
exports.trackResponse = trackResponse;
/**
 * Build a completed response: the external representation of a response
 * that's been completely written out and sent back to the client.
 */
function waitForCompletedResponse(response) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = yield waitForBody(response.body, response.getHeaders());
        response.timingEvents.responseSentTimestamp = response.timingEvents.responseSentTimestamp || now();
        const completedResponse = _(response).pick([
            'id',
            'statusCode',
            'timingEvents',
            'tags'
        ]).assign({
            statusMessage: '',
            headers: cleanUpHeaders(response.getHeaders()),
            body: body
        }).valueOf();
        if (!(response instanceof http2.Http2ServerResponse)) {
            // H2 has no status messages, and generates a warning if you look for one
            completedResponse.statusMessage = response.statusMessage;
        }
        return completedResponse;
    });
}
exports.waitForCompletedResponse = waitForCompletedResponse;
// Take raw HTTP bytes recieved, have a go at parsing something useful out of them.
// Very lax - this is a method to use when normal parsing has failed, not as standard
function tryToParseHttp(input, socket) {
    var _a;
    const req = {};
    try {
        req.protocol = socket.lastHopEncrypted ? "https" : "http"; // Wild guess really
        // For TLS sockets, we default the hostname to the name given by SNI. Might be overridden
        // by the URL or Host header later, if available.
        if (socket instanceof tls_1.TLSSocket)
            req.hostname = socket.servername;
        const lines = (0, buffer_utils_1.splitBuffer)(input, '\r\n');
        const requestLine = lines[0].slice(0, lines[0].length).toString('ascii');
        const [method, rawUri, httpProtocol] = requestLine.split(" ");
        if (method)
            req.method = method.slice(0, 15); // With overflows this could be *anything*. Limit it slightly.
        // An empty line delineates the headers from the body
        const emptyLineIndex = _.findIndex(lines, (line) => line.length === 0);
        try {
            const headerLines = lines.slice(1, emptyLineIndex === -1 ? undefined : emptyLineIndex);
            const headers = headerLines
                .map((line) => (0, buffer_utils_1.splitBuffer)(line, ':', 2))
                .filter((line) => line.length > 1)
                .map((headerParts) => headerParts.map(p => p.toString('utf8')))
                .reduce((headers, headerPair) => {
                const headerName = headerPair[0];
                const headerValue = headerPair[1].trim();
                const existingKey = _.findKey(headers, (_v, key) => key.toLowerCase() === headerName);
                if (existingKey) {
                    const existingValue = headers[existingKey];
                    if (Array.isArray(existingValue)) {
                        headers[existingKey] = existingValue.concat(headerValue);
                    }
                    else {
                        headers[existingKey] = [existingValue, headerValue];
                    }
                }
                else {
                    headers[headerName] = headerValue;
                }
                return headers;
            }, {});
            req.headers = headers;
        }
        catch (e) { }
        try {
            const parsedUrl = url.parse(rawUri);
            req.path = (_a = parsedUrl.path) !== null && _a !== void 0 ? _a : undefined;
            const hostHeader = _.find(req.headers, (_value, key) => key.toLowerCase() === 'host');
            if (hostHeader) {
                req.hostname = Array.isArray(hostHeader) ? hostHeader[0] : hostHeader;
            }
            else if (parsedUrl.hostname) {
                req.hostname = parsedUrl.hostname;
            }
            if (rawUri.includes('://') || !req.hostname) {
                // URI is absolute, or we have no way to guess the host at all
                req.url = rawUri;
            }
            else {
                // URI is relative (or invalid) and we have a host: use it
                req.url = `${req.protocol}://${req.hostname}${rawUri.startsWith('/') ? '' : '/' // Add a slash if the URI is garbage
                }${rawUri}`;
            }
        }
        catch (e) { }
        try {
            const httpVersion = httpProtocol.split('/')[1];
            req.httpVersion = httpVersion;
        }
        catch (e) { }
    }
    catch (e) { }
    return req;
}
exports.tryToParseHttp = tryToParseHttp;
//# sourceMappingURL=request-utils.js.map