"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAdminServerModel = void 0;
const _ = require("lodash");
const graphql_subscriptions_1 = require("graphql-subscriptions");
const rule_deserialization_1 = require("../rules/rule-deserialization");
const REQUEST_INITIATED_TOPIC = 'request-initiated';
const REQUEST_RECEIVED_TOPIC = 'request-received';
const RESPONSE_COMPLETED_TOPIC = 'response-completed';
const REQUEST_ABORTED_TOPIC = 'request-aborted';
const TLS_CLIENT_ERROR_TOPIC = 'tls-client-error';
const CLIENT_ERROR_TOPIC = 'client-error';
function buildMockedEndpointData(endpoint) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            id: endpoint.id,
            explanation: endpoint.toString(true),
            seenRequests: yield endpoint.getSeenRequests(),
            isPending: yield endpoint.isPending()
        };
    });
}
function buildAdminServerModel(mockServer, stream, ruleParameters) {
    const pubsub = new graphql_subscriptions_1.PubSub();
    mockServer.on('request-initiated', (request) => {
        pubsub.publish(REQUEST_INITIATED_TOPIC, {
            requestInitiated: request
        });
    });
    mockServer.on('request', (request) => {
        pubsub.publish(REQUEST_RECEIVED_TOPIC, {
            requestReceived: request
        });
    });
    mockServer.on('response', (response) => {
        pubsub.publish(RESPONSE_COMPLETED_TOPIC, {
            responseCompleted: response
        });
    });
    mockServer.on('abort', (request) => {
        pubsub.publish(REQUEST_ABORTED_TOPIC, {
            requestAborted: request
        });
    });
    mockServer.on('tls-client-error', (request) => {
        pubsub.publish(TLS_CLIENT_ERROR_TOPIC, {
            failedTlsRequest: request
        });
    });
    mockServer.on('client-error', (error) => {
        pubsub.publish(CLIENT_ERROR_TOPIC, {
            failedClientRequest: error
        });
    });
    return {
        Query: {
            mockedEndpoints: () => __awaiter(this, void 0, void 0, function* () {
                return Promise.all((yield mockServer.getMockedEndpoints()).map(buildMockedEndpointData));
            }),
            pendingEndpoints: () => __awaiter(this, void 0, void 0, function* () {
                return Promise.all((yield mockServer.getPendingEndpoints()).map(buildMockedEndpointData));
            }),
            mockedEndpoint: (__, { id }) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = _.find(yield mockServer.getMockedEndpoints(), (endpoint) => {
                    return endpoint.id === id;
                });
                if (!endpoint)
                    return null;
                return buildMockedEndpointData(endpoint);
            })
        },
        Mutation: {
            addRule: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.addRule((0, rule_deserialization_1.deserializeRuleData)(input, stream, ruleParameters));
            }),
            addRules: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.addRequestRules(...input.map((rule) => (0, rule_deserialization_1.deserializeRuleData)(rule, stream, ruleParameters)));
            }),
            setRules: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.setRequestRules(...input.map((rule) => (0, rule_deserialization_1.deserializeRuleData)(rule, stream, ruleParameters)));
            }),
            setFallbackRule: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.setFallbackRequestRule((0, rule_deserialization_1.deserializeRuleData)(input, stream, ruleParameters));
            }),
            addWebSocketRule: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.addWebSocketRule((0, rule_deserialization_1.deserializeWebSocketRuleData)(input, stream, ruleParameters));
            }),
            addWebSocketRules: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.addWebSocketRules(...input.map((rule) => (0, rule_deserialization_1.deserializeWebSocketRuleData)(rule, stream, ruleParameters)));
            }),
            setWebSocketRules: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.setWebSocketRules(...input.map((rule) => (0, rule_deserialization_1.deserializeWebSocketRuleData)(rule, stream, ruleParameters)));
            })
        },
        Subscription: {
            requestInitiated: {
                subscribe: () => pubsub.asyncIterator(REQUEST_INITIATED_TOPIC)
            },
            requestReceived: {
                subscribe: () => pubsub.asyncIterator(REQUEST_RECEIVED_TOPIC)
            },
            responseCompleted: {
                subscribe: () => pubsub.asyncIterator(RESPONSE_COMPLETED_TOPIC)
            },
            requestAborted: {
                subscribe: () => pubsub.asyncIterator(REQUEST_ABORTED_TOPIC)
            },
            failedTlsRequest: {
                subscribe: () => pubsub.asyncIterator(TLS_CLIENT_ERROR_TOPIC)
            },
            failedClientRequest: {
                subscribe: () => pubsub.asyncIterator(CLIENT_ERROR_TOPIC)
            }
        },
        Request: {
            body: (request) => {
                return request.body.buffer;
            }
        },
        Response: {
            body: (response) => {
                return response.body.buffer;
            }
        },
        ClientError: {
            response: (error) => {
                if (error.response === 'aborted')
                    return undefined;
                else
                    return error.response;
            }
        }
    };
}
exports.buildAdminServerModel = buildAdminServerModel;
//# sourceMappingURL=mockttp-admin-model.js.map