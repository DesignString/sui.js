/// <reference types="node" />
import stream = require('stream');
import http = require('http');
import { EventEmitter } from 'events';
export declare const DEFAULT_ADMIN_SERVER_PORT = 45454;
/**
 * @deprecated Alias for DEFAULT_ADMIN_SERVER_PORT
 */
export declare const DEFAULT_STANDALONE_PORT = 45454;
export declare enum Method {
    GET = 0,
    POST = 1,
    PUT = 2,
    DELETE = 3,
    PATCH = 4,
    HEAD = 5,
    OPTIONS = 6
}
export interface Headers {
    host?: string;
    'content-length'?: string;
    'content-type'?: string;
    'user-agent'?: string;
    cookie?: string;
    ':method'?: string;
    ':scheme'?: string;
    ':authority'?: string;
    ':path'?: string;
    [key: string]: undefined | string | string[];
}
export interface Request {
    id: string;
    matchedRuleId?: string;
    protocol: string;
    httpVersion?: string;
    method: string;
    url: string;
    path: string;
    remoteIpAddress?: string;
    remotePort?: number;
    hostname?: string;
    headers: Headers;
    timingEvents: TimingEvents | {};
    tags: string[];
}
export interface TlsRequest {
    hostname?: string;
    remoteIpAddress: string;
    remotePort: number;
    failureCause: 'closed' | 'reset' | 'cert-rejected' | 'no-shared-cipher' | 'unknown';
    tags: string[];
    timingEvents: TlsTimingEvents;
}
export interface TlsTimingEvents {
    startTime: number;
    connectTimestamp: number;
    failureTimestamp: number;
    handshakeTimestamp?: number;
    tunnelTimestamp?: number;
}
export interface OngoingRequest extends Request, EventEmitter {
    body: OngoingBody;
    timingEvents: TimingEvents;
}
export interface OngoingBody {
    asStream: () => stream.Readable;
    asBuffer: () => Promise<Buffer>;
    asText: () => Promise<string>;
    asJson: () => Promise<object>;
    asFormData: () => Promise<{
        [key: string]: string | string[] | undefined;
    }>;
}
export interface CompletedBody {
    /**
     * The raw bytes of the response. If a content encoding was used, this is
     * the raw encoded data.
     */
    buffer: Buffer;
    /**
     * @deprecated Use `getDecodedBuffer()` instead with promises, to support
     * more encodings and improve performance.
     */
    decodedBuffer: Buffer | undefined;
    /**
     * The decoded bytes of the response. If no encoding was used, this is the
     * same as `.buffer`. The response is decoded and returned asynchronously
     * as a Promise.
     */
    getDecodedBuffer(): Promise<Buffer | undefined>;
    /**
     * @deprecated Use `getText()` instead with promises, to support
     * more encodings and improve performance.
     */
    text: string | undefined;
    /**
     * The contents of the response, decoded and parsed as a UTF-8 string.
     * The response is decoded and returned asynchronously as a Promise.
     */
    getText(): Promise<string | undefined>;
    /**
     * @deprecated Use `getJson()` instead with promises, to support
     * more encodings and improve performance.
     */
    json: object | undefined;
    /**
     * The contents of the response, decoded, parsed as UTF-8 string, and
     * then parsed a JSON. The response is decoded and returned asynchronously
     * as a Promise.
     */
    getJson(): Promise<object | undefined>;
    /**
     * @deprecated Use `getDecodedBuffer()` instead with promises, to support
     * more encodings and improve performance.
     */
    formData: {
        [key: string]: string | string[] | undefined;
    } | undefined;
    /**
     * The contents of the response, decoded, parsed as UTF-8 string, and
     * then parsed form-encoded data. The response is decoded and returned
     * asynchronously as a Promise.
     */
    getFormData(): Promise<{
        [key: string]: string | string[] | undefined;
    } | undefined>;
}
export interface InitiatedRequest extends Request {
    timingEvents: TimingEvents;
}
export interface CompletedRequest extends Request {
    body: CompletedBody;
}
export interface TimingEvents {
    startTime: number;
    startTimestamp: number;
    bodyReceivedTimestamp?: number;
    headersSentTimestamp?: number;
    responseSentTimestamp?: number;
    abortedTimestamp?: number;
}
export interface OngoingResponse extends http.ServerResponse {
    id: string;
    getHeaders(): Headers;
    body: OngoingBody;
    timingEvents: TimingEvents;
    tags: string[];
}
export interface CompletedResponse {
    id: string;
    statusCode: number;
    statusMessage: string;
    headers: Headers;
    body: CompletedBody;
    timingEvents: TimingEvents | {};
    tags: string[];
}
/**
 * A client error event describes a request (or our best guess at parsing it),
 * that wasn't correctly completed, and the error response it received, or
 * 'aborted' if the connection was disconnected before we could respond.
 */
export interface ClientError {
    errorCode?: string;
    request: {
        id: string;
        timingEvents: TimingEvents;
        tags: string[];
        protocol?: string;
        httpVersion?: string;
        method?: string;
        url?: string;
        path?: string;
        headers: Headers;
        remoteIpAddress?: string;
        remotePort?: number;
    };
    response: CompletedResponse | 'aborted';
}
/**
 * A mocked endpoint provides methods to see the current state of
 * a mock rule.
 */
export interface MockedEndpoint {
    id: string;
    /**
     * Get the requests that this endpoint has seen so far.
     *
     * This method returns a promise, which resolves with the requests seen
     * up until now, once all ongoing requests have terminated. The returned
     * lists are immutable, so won't change if more requests arrive in future.
     * Call `getSeenRequests` again later to get an updated list.
     *
     * Requests are included here once the response is completed, even if the
     * responses failed or exceptions are thrown elsewhere. To watch for errors
     * or detailed response info, look at the various server.on(event) methods.
     */
    getSeenRequests(): Promise<CompletedRequest[]>;
    /**
     * Reports whether this endpoint is still pending: if it either hasn't seen the
     * specified number of requests (if one was specified e.g. with .twice())
     * or if it hasn't seen at least one request, by default.
     *
     * This method returns a promise, which resolves with the result once all
     * ongoing requests have terminated.
     */
    isPending(): Promise<boolean>;
}
export interface MockedEndpointData {
    id: string;
    explanation?: string;
    seenRequests: CompletedRequest[];
    isPending: boolean;
}
export interface Explainable {
    explain(): string;
}
export interface ProxyEnvConfig {
    HTTP_PROXY: string;
    HTTPS_PROXY: string;
}
export declare type defaultMaxListeners = typeof EventEmitter.defaultMaxListeners;
